<head>
  <meta charset="UTF-8">
  <style>
    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background-color: #000;
    }

    #control-panel {
      position: fixed;
      top: 12px;
      left: 12px;
      padding: 12px 14px;
      background: rgba(0, 0, 0, 0.75);
      color: #f5f5f5;
      border-radius: 8px;
      max-width: 320px;
      z-index: 10;
      backdrop-filter: blur(10px);
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
    }

    #control-panel h2 {
      margin: 0 0 8px;
      font-size: 14px;
      letter-spacing: 0.03em;
      text-transform: uppercase;
      color: #c0c0ff;
    }

    #control-panel label {
      display: block;
      font-size: 12px;
      margin-bottom: 4px;
      color: #e0e0ff;
    }

    #splat-url-input {
      width: 100%;
      box-sizing: border-box;
      padding: 6px 8px;
      font-size: 12px;
      border-radius: 4px;
      border: 1px solid rgba(255, 255, 255, 0.25);
      background: rgba(10, 10, 30, 0.9);
      color: #f5f5f5;
      outline: none;
    }

    #splat-url-input:focus {
      border-color: #7f5cff;
      box-shadow: 0 0 0 1px rgba(127, 92, 255, 0.6);
    }

    #load-splat-btn {
      margin-top: 8px;
      padding: 6px 10px;
      font-size: 12px;
      border-radius: 4px;
      border: none;
      cursor: pointer;
      background: linear-gradient(135deg, #7f5cff, #ff5cf0);
      color: #fff;
      font-weight: 500;
    }

    #load-splat-btn:hover {
      filter: brightness(1.1);
    }

    #control-panel small {
      display: block;
      margin-top: 6px;
      font-size: 11px;
      color: #c0c0c0;
    }

    #view-buttons {
      margin-top: 10px;
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
    }

    .view-toggle-btn {
      flex: 1 1 calc(33% - 4px);
      padding: 6px 8px;
      font-size: 11px;
      border-radius: 4px;
      border: 1px solid rgba(255, 255, 255, 0.25);
      background: rgba(20, 20, 40, 0.9);
      color: #f5f5f5;
      cursor: pointer;
    }

    .view-toggle-btn.active {
      border-color: #7f5cff;
      background: linear-gradient(135deg, #7f5cff, #ff5cf0);
    }

    #controls-hint {
      margin-top: 8px;
      font-size: 11px;
      color: #a0ffcb;
    }

    #debug-panel {
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px solid rgba(255, 255, 255, 0.15);
    }

    #debug-panel h3 {
      margin: 0 0 8px;
      font-size: 12px;
      letter-spacing: 0.03em;
      text-transform: uppercase;
      color: #ffc080;
    }

    .debug-checkbox {
      display: flex;
      align-items: center;
      margin-bottom: 6px;
      font-size: 11px;
      color: #e0e0ff;
      cursor: pointer;
    }

    .debug-checkbox input {
      margin-right: 6px;
      cursor: pointer;
    }

    #coord-info {
      margin-top: 8px;
      padding: 8px;
      background: rgba(0, 0, 0, 0.4);
      border-radius: 4px;
      font-size: 10px;
      font-family: 'Courier New', monospace;
      color: #a0ffa0;
      line-height: 1.4;
    }

    #mesh-tools-panel {
      position: fixed;
      top: 12px;
      right: 12px;
      padding: 12px 14px;
      background: rgba(0, 0, 0, 0.75);
      color: #f5f5f5;
      border-radius: 8px;
      width: 280px;
      z-index: 10;
      backdrop-filter: blur(10px);
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
    }

    #mesh-tools-panel h2 {
      margin: 0 0 12px;
      font-size: 14px;
      letter-spacing: 0.03em;
      text-transform: uppercase;
      color: #ffc080;
    }

    .tool-buttons {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
      margin-bottom: 12px;
    }

    .tool-btn {
      padding: 10px 8px;
      font-size: 12px;
      border-radius: 6px;
      border: 1px solid rgba(255, 255, 255, 0.25);
      background: rgba(20, 20, 40, 0.9);
      color: #f5f5f5;
      cursor: pointer;
      transition: all 0.2s;
      font-weight: 500;
    }

    .tool-btn:hover {
      border-color: rgba(127, 92, 255, 0.5);
      background: rgba(30, 30, 50, 0.95);
    }

    .tool-btn.active {
      border-color: #ff5cf0;
      background: linear-gradient(135deg, #7f5cff, #ff5cf0);
      box-shadow: 0 4px 12px rgba(255, 92, 240, 0.3);
    }

    .tool-settings {
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px solid rgba(255, 255, 255, 0.15);
    }

    .tool-settings label {
      display: block;
      font-size: 11px;
      margin-bottom: 8px;
      color: #e0e0ff;
    }

    .tool-settings input[type="range"] {
      width: 100%;
      margin-top: 4px;
    }

    .tool-settings .value-display {
      color: #7f5cff;
      font-weight: 600;
    }

    #mesh-list {
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px solid rgba(255, 255, 255, 0.15);
      max-height: 200px;
      overflow-y: auto;
    }

    #mesh-list h3 {
      margin: 0 0 8px;
      font-size: 11px;
      letter-spacing: 0.03em;
      text-transform: uppercase;
      color: #ffc080;
    }

    .mesh-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 6px 8px;
      margin-bottom: 4px;
      background: rgba(20, 20, 40, 0.6);
      border-radius: 4px;
      font-size: 11px;
    }

    .mesh-item:hover {
      background: rgba(30, 30, 50, 0.8);
    }

    .mesh-item-info {
      flex: 1;
    }

    .mesh-item-type {
      display: inline-block;
      padding: 2px 6px;
      margin-right: 6px;
      background: rgba(127, 92, 255, 0.3);
      border-radius: 3px;
      font-size: 9px;
      text-transform: uppercase;
    }

    .delete-mesh-btn {
      padding: 2px 8px;
      font-size: 10px;
      border-radius: 3px;
      border: 1px solid rgba(255, 92, 92, 0.5);
      background: rgba(255, 92, 92, 0.2);
      color: #ff5c5c;
      cursor: pointer;
    }

    .delete-mesh-btn:hover {
      background: rgba(255, 92, 92, 0.4);
    }

    .mesh-actions {
      margin-top: 12px;
      display: flex;
      gap: 6px;
    }

    .mesh-action-btn {
      flex: 1;
      padding: 6px 8px;
      font-size: 10px;
      border-radius: 4px;
      border: 1px solid rgba(255, 255, 255, 0.25);
      background: rgba(20, 20, 40, 0.9);
      color: #f5f5f5;
      cursor: pointer;
    }

    .mesh-action-btn:hover {
      background: rgba(30, 30, 50, 0.95);
    }

    .tool-hint {
      margin-top: 12px;
      padding: 8px;
      background: rgba(127, 92, 255, 0.15);
      border-left: 3px solid #7f5cff;
      border-radius: 4px;
      font-size: 10px;
      line-height: 1.5;
      color: #c0c0ff;
    }
  </style>
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdnjs.cloudflare.com/ajax/libs/three.js/0.178.0/three.module.js",
      "@sparkjsdev/spark": "https://sparkjs.dev/releases/spark/0.1.10/spark.module.js"
    }
  }
</script>

  <div id="control-panel">
    <h2>Import my splat</h2>
    <label for="splat-url-input">Splat / SPZ URL</label>
    <input id="splat-url-input" type="text" value="https://sparkjs.dev/assets/splats/butterfly.spz"
      placeholder="Paste your .spz URL here" />
    <button id="load-splat-btn">Load file</button>
    <small>You can paste your own URL here to import and view your file.</small>
    <label for="splat-file-input" style="margin-top: 8px;">Or choose a file from your laptop</label>
    <input id="splat-file-input" type="file" accept=".spz,.ply,.splat"
      style="margin-top: 4px; font-size: 11px; color: #f5f5f5;" />
    <div id="view-buttons">
      <button id="first-person-btn" class="view-toggle-btn active">First person view</button>
      <button id="third-person-btn" class="view-toggle-btn">Third person view</button>
      <button id="drone-view-btn" class="view-toggle-btn">Drone view</button>
    </div>
    <div id="controls-hint">WASD to move, drag mouse to aim. Drone view lets you fly with mouse pitch.</div>

    <div id="debug-panel">
      <h3>Debug Visualization</h3>
      <label class="debug-checkbox">
        <input type="checkbox" id="show-bounding-box" checked>
        Show Bounding Box
      </label>
      <label class="debug-checkbox">
        <input type="checkbox" id="show-coordinate-grid">
        Show Coordinate Grid
      </label>
      <label class="debug-checkbox">
        <input type="checkbox" id="show-axis-helpers">
        Show Axis Helpers
      </label>
      <label class="debug-checkbox">
        <input type="checkbox" id="show-collision">
        Show Collision Grid
      </label>
      <label class="debug-checkbox">
        <input type="checkbox" id="noclip">
        Noclip (Walk Through Walls)
      </label>

      <div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid rgba(255,255,255,0.15);">
        <h3 style="margin: 0 0 8px; font-size: 11px; color: #ffc080;">Alignment Offset</h3>
        <label style="display: block; font-size: 10px; margin-bottom: 4px;">
          X Offset: <span id="offset-x-value">0</span>m
          <input type="range" id="offset-x" min="-10" max="10" step="0.1" value="0" style="width: 100%;">
        </label>
        <label style="display: block; font-size: 10px; margin-bottom: 4px;">
          Y Offset: <span id="offset-y-value">0</span>m
          <input type="range" id="offset-y" min="-10" max="10" step="0.1" value="0" style="width: 100%;">
        </label>
        <label style="display: block; font-size: 10px; margin-bottom: 4px;">
          Z Offset: <span id="offset-z-value">0</span>m
          <input type="range" id="offset-z" min="-10" max="10" step="0.1" value="0" style="width: 100%;">
        </label>
        <div id="movement-debug"
          style="position: absolute; top: 10px; right: 10px; color: lime; font-family: monospace; background: rgba(0,0,0,0.5); padding: 10px; pointer-events: none;">
          Debug Info
        </div>
      </div>

      <div id="coord-info"></div>
    </div>
  </div>

  <div id="mesh-tools-panel">
    <h2>üîß Mesh Tools</h2>

    <div class="tool-buttons">
      <button id="tool-none" class="tool-btn">None</button>
      <button id="tool-sphere" class="tool-btn">üîµ Sphere</button>
      <button id="tool-box" class="tool-btn">üì¶ Box</button>
      <button id="tool-brush" class="tool-btn">üñåÔ∏è Brush</button>
    </div>

    <div class="tool-settings">
      <label id="sphere-size-label">
        Sphere Radius: <span class="value-display" id="sphere-size-value">2.0</span>m
        <input type="range" id="sphere-size" min="0.5" max="10" step="0.5" value="2.0">
      </label>

      <label id="box-width-label">
        Box Width: <span class="value-display" id="box-width-value">3.0</span>m
        <input type="range" id="box-width" min="0.5" max="15" step="0.5" value="3.0">
      </label>

      <label id="box-height-label">
        Box Height: <span class="value-display" id="box-height-value">2.5</span>m
        <input type="range" id="box-height" min="0.5" max="10" step="0.5" value="2.5">
      </label>

      <label id="box-depth-label">
        Box Depth: <span class="value-display" id="box-depth-value">3.0</span>m
        <input type="range" id="box-depth" min="0.5" max="15" step="0.5" value="3.0">
      </label>

      <label id="brush-width-label">
        Brush Width: <span class="value-display" id="brush-width-value">1.0</span>m
        <input type="range" id="brush-width" min="0.2" max="5" step="0.2" value="1.0">
      </label>

      <label class="debug-checkbox"
        style="margin-top: 12px; border-top: 1px solid rgba(255,255,255,0.15); padding-top: 8px;">
        <input type="checkbox" id="show-created-meshes">
        Show Collision Meshes (Red)
      </label>
      <label class="debug-checkbox">
        <input type="checkbox" id="show-selection-highlight" checked>
        Show Selection Highlight (Yellow)
      </label>
    </div>

    <div class="tool-hint" id="tool-hint">
      Select a tool to create collision meshes
    </div>

    <div id="mesh-list">
      <h3>Created Meshes (<span id="mesh-count">0</span>)</h3>
      <div id="mesh-items"></div>
      <div class="mesh-actions">
        <button class="mesh-action-btn" id="export-meshes">üíæ Export Meshes</button>
        <button class="mesh-action-btn" id="export-scene">üåç Export Project (JSON)</button>
        <button class="mesh-action-btn" id="export-ply-package">üì¶ Export PLY Package</button>
        <button class="mesh-action-btn" id="import-meshes">üìÇ Import Meshes</button>
        <button class="mesh-action-btn" id="import-scene">üåê Import Scene</button>
        <button class="mesh-action-btn" id="clear-meshes">üóëÔ∏è Clear All</button>
      </div>
    </div>
  </div>

  <input type="file" id="mesh-import-input" accept=".json" style="display: none;">
  <input type="file" id="scene-import-input" accept=".json" style="display: none;">

  <script type="module">
    import * as THREE from "three";
    import { SplatMesh, SplatEdit, SplatEditSdf, SplatEditSdfType, SplatEditRgbaBlendMode } from "@sparkjsdev/spark";
    import { ConvexGeometry } from 'https://cdn.jsdelivr.net/npm/three@0.178.0/examples/jsm/geometries/ConvexGeometry.js';
    import { PLYExporter } from 'https://cdn.jsdelivr.net/npm/three@0.178.0/examples/jsm/exporters/PLYExporter.js';
    import JSZip from 'https://esm.run/jszip';

    const scene = new THREE.Scene();

    let collisionMap = null;
    let gridMetadata = null;
    let floorY = 0; // Will be updated from metadata

    async function loadCollisionMap() {
      // Collision map removed as per user request
      return {
        bbox: {
          x: [-1000, 1000],
          y: [-100, 100],
          z: [-1000, 1000],
        },
        center: [0, 0, 0],
      };
    }

    const boundsData = await loadCollisionMap();
    const worldBounds = boundsData.bbox;

    const camera = new THREE.PerspectiveCamera(
      60,
      window.innerWidth / window.innerHeight,
      0.1,
      1000,
    );
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x000000, 1);
    document.body.appendChild(renderer.domElement);

    // simple lighting + ground for more "world" feeling
    const ambient = new THREE.AmbientLight(0xffffff, 0.4);
    scene.add(ambient);
    const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
    dirLight.position.set(5, 10, 5);
    scene.add(dirLight);

    const groundGeo = new THREE.PlaneGeometry(80, 80);
    const groundMat = new THREE.MeshStandardMaterial({
      color: 0x101318,
      roughness: 0.9,
      metalness: 0.0,
    });
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotation.x = -Math.PI / 2;
    ground.position.y = floorY; // Use the loaded floor height
    ground.receiveShadow = true;
    scene.add(ground);

    // ===== DEBUG VISUALIZATION OBJECTS =====
    let boundingBox = null;
    let gridHelper = null;
    let axesHelper = null;
    let collisionGridGroup = null;

    function createBoundingBox() {
      if (!gridMetadata) return;

      const minX = gridMetadata.min_x;
      const minZ = gridMetadata.min_z;
      const maxX = minX + gridMetadata.cols * gridMetadata.grid_size;
      const maxZ = minZ + gridMetadata.rows * gridMetadata.grid_size;
      const minY = gridMetadata.min_y || -5;

      // Calculate actual Y extent from collision data
      let actualMaxY = minY;
      for (const cell of Object.values(collisionMap)) {
        if (cell.y > actualMaxY) actualMaxY = cell.y;
      }
      const maxY = actualMaxY + 2; // Add 2m headroom

      const width = maxX - minX;
      const depth = maxZ - minZ;
      const height = maxY - minY;

      const geometry = new THREE.BoxGeometry(width, height, depth);
      const edges = new THREE.EdgesGeometry(geometry);
      const material = new THREE.LineBasicMaterial({ color: 0x00ffff, linewidth: 2 });
      const box = new THREE.LineSegments(edges, material);

      box.position.set(
        (minX + maxX) / 2,
        (minY + maxY) / 2,
        (minZ + maxZ) / 2
      );

      return box;
    }

    function createGridHelper() {
      if (!gridMetadata) return;

      const minX = gridMetadata.min_x;
      const minZ = gridMetadata.min_z;
      const maxX = minX + gridMetadata.cols * gridMetadata.grid_size;
      const maxZ = minZ + gridMetadata.rows * gridMetadata.grid_size;

      const width = maxX - minX;
      const depth = maxZ - minZ;
      const divisions = Math.max(gridMetadata.cols, gridMetadata.rows);

      const grid = new THREE.GridHelper(
        Math.max(width, depth),
        Math.floor(divisions / 5), // Fewer divisions for clarity
        0xffff00,
        0x444444
      );

      grid.position.set(
        (minX + maxX) / 2,
        floorY,
        (minZ + maxZ) / 2
      );

      return grid;
    }

    function createAxesHelper() {
      const size = 2;
      const axes = new THREE.AxesHelper(size);
      axes.position.set(0, floorY + 0.01, 0);
      return axes;
    }

    function createCollisionGrid() {
      if (!gridMetadata || !collisionMap) return;

      const group = new THREE.Group();
      const cellSize = gridMetadata.grid_size;

      // Create a single geometry for efficiency
      const planeGeom = new THREE.PlaneGeometry(cellSize * 0.9, cellSize * 0.9);

      // Don't sample - show all cells for accuracy
      let blockedCount = 0;
      let walkableCount = 0;

      for (const [key, cell] of Object.entries(collisionMap)) {
        const [c, r] = key.split(',').map(Number);

        const x = gridMetadata.min_x + c * cellSize + cellSize / 2;
        const z = gridMetadata.min_z + r * cellSize + cellSize / 2;
        const y = cell.y + 0.01; // Slightly above the floor

        // Color based on blocked status
        const isBlocked = cell.b === 1;
        const color = isBlocked ? 0xff4444 : 0x44ff44;
        const opacity = isBlocked ? 0.7 : 0.2;

        if (isBlocked) blockedCount++;
        else walkableCount++;

        const material = new THREE.MeshBasicMaterial({
          color: color,
          transparent: true,
          opacity: opacity,
          side: THREE.DoubleSide,
          depthWrite: false
        });

        const plane = new THREE.Mesh(planeGeom, material);
        plane.rotation.x = -Math.PI / 2;
        plane.position.set(x, y, z);
        group.add(plane);
      }

      console.log(`Collision grid: ${blockedCount} blocked, ${walkableCount} walkable cells`);
      return group;
    }

    // function createDirectionalLabels() { ... } // Removed

    // Initialize visualization objects
    boundingBox = createBoundingBox();
    gridHelper = createGridHelper();
    axesHelper = createAxesHelper();
    // let directionalLabels = createDirectionalLabels();

    if (boundingBox) scene.add(boundingBox);
    if (gridHelper) scene.add(gridHelper);
    if (axesHelper) scene.add(axesHelper);
    // if (directionalLabels) scene.add(directionalLabels);

    // Hook up debug controls
    const showBoundsCheckbox = document.getElementById('show-bounding-box');
    const showGridCheckbox = document.getElementById('show-coordinate-grid');
    const showAxesCheckbox = document.getElementById('show-axis-helpers');
    const showCollisionCheckbox = document.getElementById('show-collision');
    const coordInfo = document.getElementById('coord-info');

    if (showBoundsCheckbox) {
      showBoundsCheckbox.addEventListener('change', (e) => {
        if (boundingBox) boundingBox.visible = e.target.checked;
      });
    }

    if (showGridCheckbox) {
      showGridCheckbox.addEventListener('change', (e) => {
        if (gridHelper) gridHelper.visible = e.target.checked;
      });
    }

    if (showAxesCheckbox) {
      showAxesCheckbox.addEventListener('change', (e) => {
        if (axesHelper) axesHelper.visible = e.target.checked;
      });
    }

    if (showCollisionCheckbox) {
      showCollisionCheckbox.addEventListener('change', (e) => {
        if (e.target.checked) {
          if (!collisionGridGroup) {
            collisionGridGroup = createCollisionGrid();
            if (collisionGridGroup) scene.add(collisionGridGroup);
          } else {
            collisionGridGroup.visible = true;
          }
        } else {
          if (collisionGridGroup) collisionGridGroup.visible = false;
        }
      });
    }

    // Update coordinate info display
    function updateCoordInfo() {
      if (!coordInfo || !gridMetadata) return;

      const minX = gridMetadata.min_x.toFixed(2);
      const minZ = gridMetadata.min_z.toFixed(2);
      const maxX = (gridMetadata.min_x + gridMetadata.cols * gridMetadata.grid_size).toFixed(2);
      const maxZ = (gridMetadata.min_z + gridMetadata.rows * gridMetadata.grid_size).toFixed(2);

      // Calculate actual Y range from collision data
      let minY = gridMetadata.min_y;
      let maxY = gridMetadata.min_y;
      for (const cell of Object.values(collisionMap)) {
        if (cell.y < minY) minY = cell.y;
        if (cell.y > maxY) maxY = cell.y;
      }

      const playerX = player.position.x.toFixed(2);
      const playerY = player.position.y.toFixed(2);
      const playerZ = player.position.z.toFixed(2);

      /*
      coordInfo.innerHTML = `
      <strong>Map Bounds:</strong><br>
      X: ${minX} to ${maxX}<br>
      Y: ${minY.toFixed(2)} to ${maxY.toFixed(2)}<br>
      Z: ${minZ} to ${maxZ}<br>
      Grid: ${gridMetadata.cols} √ó ${gridMetadata.rows}<br>
      Cell Size: ${gridMetadata.grid_size}m<br>
      <br>
      <strong>Player Position:</strong><br>
      X: ${playerX}, Y: ${playerY}, Z: ${playerZ}
    `;
    */
      coordInfo.innerHTML = ''; // Clear it
    }

    // 3D Robot Player
    function createRobot() {
      const robot = new THREE.Group();

      // Materials
      const blueMat = new THREE.MeshStandardMaterial({ color: 0x3399ff, roughness: 0.4 });
      const darkBlueMat = new THREE.MeshStandardMaterial({ color: 0x1a3366, roughness: 0.6 });
      const yellowMat = new THREE.MeshStandardMaterial({ color: 0xffcc00, roughness: 0.3 });
      const whiteMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.2, emissive: 0x222222 });
      const blackMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.8 });

      // Body (Cylinder-ish box)
      const bodyGeo = new THREE.CylinderGeometry(0.3, 0.25, 0.6, 16);
      const body = new THREE.Mesh(bodyGeo, blueMat);
      body.position.y = 0.9; // Legs are approx 0.6m tall
      robot.add(body);

      // Chest plate (Yellow detail)
      const chestGeo = new THREE.BoxGeometry(0.3, 0.2, 0.1);
      const chest = new THREE.Mesh(chestGeo, yellowMat);
      chest.position.set(0, 0.1, 0.25);
      body.add(chest);

      // Head
      const headGroup = new THREE.Group();
      headGroup.position.y = 1.35;
      robot.add(headGroup);

      // Head Main Box
      const headGeo = new THREE.BoxGeometry(0.5, 0.4, 0.45);
      const head = new THREE.Mesh(headGeo, blueMat);
      headGroup.add(head);

      // Face Screen
      const faceGeo = new THREE.BoxGeometry(0.4, 0.25, 0.05);
      const face = new THREE.Mesh(faceGeo, whiteMat);
      face.position.set(0, -0.02, 0.21);
      headGroup.add(face);

      // Eyes (Simple texture or just black dots on screen? Let's do simple geometry eyes)
      const eyeGeo = new THREE.SphereGeometry(0.06, 16, 16);
      const leftEye = new THREE.Mesh(eyeGeo, blackMat);
      leftEye.position.set(-0.1, 0, 0.03);
      leftEye.scale.z = 0.5;
      face.add(leftEye);

      const rightEye = new THREE.Mesh(eyeGeo, blackMat);
      rightEye.position.set(0.1, 0, 0.03);
      rightEye.scale.z = 0.5;
      face.add(rightEye);

      // Yellow Stripe on top
      const stripeGeo = new THREE.BoxGeometry(0.15, 0.05, 0.46);
      const stripe = new THREE.Mesh(stripeGeo, yellowMat);
      stripe.position.y = 0.22;
      headGroup.add(stripe);

      // Antenna
      const antStemGeo = new THREE.CylinderGeometry(0.02, 0.02, 0.2);
      const antStem = new THREE.Mesh(antStemGeo, blackMat);
      antStem.position.set(0, 0.3, 0);
      headGroup.add(antStem);

      const antBallGeo = new THREE.SphereGeometry(0.05);
      const antBall = new THREE.Mesh(antBallGeo, yellowMat);
      antBall.position.y = 0.1;
      antStem.add(antBall);

      // Ear Cups
      const earGeo = new THREE.CylinderGeometry(0.12, 0.12, 0.1, 16);
      earGeo.rotateZ(Math.PI / 2);
      const leftEar = new THREE.Mesh(earGeo, yellowMat);
      leftEar.position.x = -0.28;
      headGroup.add(leftEar);

      const rightEar = new THREE.Mesh(earGeo, yellowMat);
      rightEar.position.x = 0.28;
      headGroup.add(rightEar);

      // Arms
      function createArm(side) {
        const armGroup = new THREE.Group();
        const xDir = side === 'left' ? -1 : 1;
        armGroup.position.set(xDir * 0.35, 1.1, 0);

        // Shoulder
        const shoulderGeo = new THREE.SphereGeometry(0.12);
        const shoulder = new THREE.Mesh(shoulderGeo, darkBlueMat);
        armGroup.add(shoulder);

        // Arm segment
        const armGeo = new THREE.CylinderGeometry(0.08, 0.07, 0.4);
        const arm = new THREE.Mesh(armGeo, blueMat);
        arm.position.y = -0.25;
        armGroup.add(arm);

        // Hand
        const handGeo = new THREE.SphereGeometry(0.1);
        const hand = new THREE.Mesh(handGeo, darkBlueMat);
        hand.position.y = -0.5;
        armGroup.add(hand);

        robot.add(armGroup);
        return armGroup;
      }

      robot.userData.leftArm = createArm('left');
      robot.userData.rightArm = createArm('right');

      // Legs
      function createLeg(side) {
        const legGroup = new THREE.Group();
        const xDir = side === 'left' ? -1 : 1;
        legGroup.position.set(xDir * 0.15, 0.6, 0);

        // Leg segment
        const legGeo = new THREE.BoxGeometry(0.18, 0.5, 0.2);
        const leg = new THREE.Mesh(legGeo, darkBlueMat);
        leg.position.y = -0.25;
        legGroup.add(leg);

        // Foot
        const footGeo = new THREE.BoxGeometry(0.2, 0.1, 0.3);
        const foot = new THREE.Mesh(footGeo, yellowMat);
        foot.position.set(0, -0.55, 0.05);
        legGroup.add(foot);

        robot.add(legGroup);
        return legGroup;
      }

      robot.userData.leftLeg = createLeg('left');
      robot.userData.rightLeg = createLeg('right');

      return robot;
    }

    const player = createRobot();

    // Physics variables
    let verticalVelocity = 0;
    const gravity = -20.0; // m/s^2
    const jumpForce = 8.0; // m/s

    let isGrounded = false;
    let walkTime = 0;

    function updatePlayer(dt) {
      if (viewMode === "drone") {
        return; // player stays still in drone mode
      }

      const forwardDir = getForwardVector(false);
      const rightDir = getRightVector();
      let move = new THREE.Vector3();
      let blocked = false;
      let blockReason = "None";

      if (keys.w) move.add(forwardDir);
      if (keys.s) move.sub(forwardDir);
      if (keys.a) move.sub(rightDir);
      if (keys.d) move.add(rightDir);

      // Jump Input
      if (keys[' '] && isGrounded) {
        verticalVelocity = jumpForce;
        isGrounded = false;
        console.log("Jump!");
      }

      // Apply Gravity
      verticalVelocity += gravity * dt;
      player.position.y += verticalVelocity * dt;

      // Ground Collision / Landing
      const groundY = getGroundHeight(player.position.x, player.position.z);

      if (player.position.y <= groundY) {
        player.position.y = groundY;
        verticalVelocity = 0;
        isGrounded = true;
      } else {
        isGrounded = false;
      }

      const isMoving = move.lengthSq() > 0;

      if (isMoving) {
        move.normalize().multiplyScalar(walkSpeed * dt);
        walkTime += dt * 10; // Animation speed

        // Predict next position
        const nextPos = player.position.clone().add(move);

        // Collision Radius Check (0.3m radius)
        const radius = 0.3;
        const checks = [
          { x: nextPos.x, z: nextPos.z },
          { x: nextPos.x + radius, z: nextPos.z },
          { x: nextPos.x - radius, z: nextPos.z },
          { x: nextPos.x, z: nextPos.z + radius },
          { x: nextPos.x, z: nextPos.z - radius },
        ];

        // Noclip check
        const noclip = document.getElementById('noclip')?.checked;

        if (!noclip) {
          for (const p of checks) {
            // Check 0: Terrain/Mesh Slope Check
            const nextGroundY = getGroundHeight(p.x, p.z);
            const currentGroundY = getGroundHeight(player.position.x, player.position.z);

            // Max step height (e.g., 0.5m)
            const maxStepHeight = 0.5;

            // If the ground at next position is too high relative to current FEET position, block it.
            // We use currentGroundY as the reference for "where feet are".
            // Note: player.position.y might be in the air (jumping), so we should compare ground-to-ground?
            // Or if jumping, we can land on higher ground.
            // If we are grounded, check step height.
            // If we are in air, check if next ground is above current player Y (hitting a wall mid-air).

            if (isGrounded) {
              if (nextGroundY > currentGroundY + maxStepHeight) {
                blocked = true;
                blockReason = `Too High (dy=${(nextGroundY - currentGroundY).toFixed(2)})`;
                break;
              }
            } else {
              // In air - block if we hit a wall (ground is above our feet)
              if (nextGroundY > player.position.y + 0.1) {
                blocked = true;
                blockReason = "Hit Wall In Air";
                break;
              }
            }

            const cell = getGridCell(p.x, p.z);

            // Check 1: Is it an explicit obstacle?
            if (cell && cell.b === 1) {
              blocked = true;
              blockReason = "Grid (b=1)";
              break;
            }
          }
        }

        if (!blocked) {
          player.position.add(move);
          // Rotate player to face movement direction
          // Smooth rotation
          const targetAngle = Math.atan2(move.x, move.z);
          // Simple lerp for rotation
          let angleDiff = targetAngle - player.rotation.y;
          // Normalize angle to -PI to PI
          while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
          while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
          player.rotation.y += angleDiff * dt * 10;
        }
      } else {
        // Reset animation when stopped
        // walkTime = 0; // Optional: reset or pause
        // Return limbs to neutral?
        const damp = Math.min(1.0, dt * 10);
        walkTime = 0; // Snap for now or lerp back
      }

      // Animate Limbs
      if (player.userData.leftLeg) {
        const legAngle = Math.sin(walkTime) * 0.5;
        const armAngle = Math.sin(walkTime) * 0.5;

        player.userData.leftLeg.rotation.x = legAngle;
        player.userData.rightLeg.rotation.x = -legAngle;

        player.userData.leftArm.rotation.x = -armAngle;
        player.userData.rightArm.rotation.x = armAngle;
      }

      // Update debug info
      const debugDiv = document.getElementById('movement-debug');
      if (debugDiv) {
        debugDiv.innerHTML = `
          View: ${viewMode}<br>
          Keys: W:${keys.w} A:${keys.a} S:${keys.s} D:${keys.d} Space:${keys[' ']}<br>
          Last Key: ${lastKey}<br>
          Pos: ${player.position.x.toFixed(2)}, ${player.position.y.toFixed(2)}, ${player.position.z.toFixed(2)}<br>
          Vel Y: ${verticalVelocity.toFixed(2)}<br>
          Grounded: ${isGrounded ? 'YES' : 'NO'}<br>
          Blocked: ${blocked ? 'YES' : 'NO'} (${blockReason})<br>
          Mesh Collision: ${checkMeshCollision(player.position.x, player.position.y + 0.75, player.position.z) ? 'YES' : 'NO'}<br>
          Bounds X: [${worldBounds.x[0].toFixed(1)}, ${worldBounds.x[1].toFixed(1)}]<br>
          Bounds Z: [${worldBounds.z[0].toFixed(1)}, ${worldBounds.z[1].toFixed(1)}]<br>
          <button onclick="window.resetPlayer()" style="pointer-events: auto; margin-top: 5px;">Reset Player</button>
        `;
      }

      clampToBounds(player.position);
    }

    function findSafeSpawn(startX, startZ) {
      if (!gridMetadata || !collisionMap) return new THREE.Vector3(startX, floorY + 2, startZ);

      // Check start pos first
      const startCell = getGridCell(startX, startZ);
      if (startCell && startCell.b !== 1) {
        return new THREE.Vector3(startX, startCell.y + 0.1, startZ);
      }

      // Spiral search
      const step = gridMetadata.grid_size;
      let x = startX;
      let z = startZ;
      let dx = step;
      let dz = 0;
      let segmentLength = 1;
      let segmentPassed = 0;

      // Search up to 100 steps
      for (let i = 0; i < 100; i++) {
        x += dx;
        z += dz;
        segmentPassed++;

        const cell = getGridCell(x, z);
        if (cell && cell.b !== 1) {
          return new THREE.Vector3(x, cell.y + 0.1, z);
        }

        if (segmentPassed === segmentLength) {
          segmentPassed = 0;
          // Rotate direction
          const temp = dx;
          dx = -dz;
          dz = temp;
          if (dz === 0) {
            segmentLength++;
          }
        }
      }

      // Fallback
      return new THREE.Vector3(startX, floorY + 2, startZ);
    }

    window.resetPlayer = function () {
      const safePos = findSafeSpawn(0, 3); // Try (0,3) first as per original
      player.position.copy(safePos);
      player.position.y += 0.5; // Drop a bit
      verticalVelocity = 0;
      console.log(`Player reset to ${safePos.x}, ${safePos.y}, ${safePos.z}`);
    };

    // Initial position - wait for map load if possible, or just set default
    // We can't await here easily, so we'll set a default and let the map load fix it later if needed?
    // Actually, loadCollisionMap is awaited at the top level. So we are good.
    const initialSpawn = findSafeSpawn(0, 3);
    player.position.copy(initialSpawn);
    player.position.y += 0.5;
    scene.add(player);

    let currentSplat = null;

    function loadSplat(url, fileName) {
      console.log("Loading splat:", url);
      if (currentSplat) {
        scene.remove(currentSplat);
      }

      try {
        const mesh = new SplatMesh({ url, fileName });
        mesh.quaternion.set(1, 0, 0, 0);

        // Apply current offsets
        const x = parseFloat(document.getElementById('offset-x')?.value || 0);
        const y = parseFloat(document.getElementById('offset-y')?.value || 0);
        const z = parseFloat(document.getElementById('offset-z')?.value || 0);
        mesh.position.set(x, y, z);

        scene.add(mesh);
        currentSplat = mesh;
        console.log("Splat loaded successfully");
      } catch (err) {
        console.error("Failed to load splat:", err);
        alert("Failed to load splat file. Check console for details.");
      }
    }

    // initial file (default)
    const defaultURL = "https://sparkjs.dev/assets/splats/butterfly.spz";
    loadSplat(defaultURL);

    // hook up the small ‚Äúimport my file‚Äù panel
    const input = document.getElementById("splat-url-input");
    const button = document.getElementById("load-splat-btn");
    const fileInput = document.getElementById("splat-file-input");

    if (input && button) {
      button.addEventListener("click", () => {
        const url = input.value.trim();
        if (!url) return;
        loadSplat(url);
      });

      input.addEventListener("keydown", (event) => {
        if (event.key === "Enter") {
          event.preventDefault();
          const url = input.value.trim();
          if (!url) return;
          loadSplat(url);
        }
      });
    }

    // local file import: creates a temporary URL for the selected file
    if (fileInput) {
      fileInput.addEventListener("change", () => {
        const files = fileInput.files;
        if (!files || files.length === 0) return;
        const file = files[0];
        const objectUrl = URL.createObjectURL(file);
        loadSplat(objectUrl, file.name);
        // optional: show that we're now using a local file instead of a remote URL
        if (input) {
          input.value = "";
          input.placeholder = "Loaded from local file: " + file.name;
        }
      });
    }

    // ===== ALIGNMENT CONTROLS =====
    const offsetXInput = document.getElementById('offset-x');
    const offsetYInput = document.getElementById('offset-y');
    const offsetZInput = document.getElementById('offset-z');
    const offsetXValue = document.getElementById('offset-x-value');
    const offsetYValue = document.getElementById('offset-y-value');
    const offsetZValue = document.getElementById('offset-z-value');

    function updateSplatPosition() {
      if (!currentSplat) return;
      const x = parseFloat(offsetXInput.value);
      const y = parseFloat(offsetYInput.value);
      const z = parseFloat(offsetZInput.value);
      currentSplat.position.set(x, y, z);
    }

    if (offsetXInput) {
      offsetXInput.addEventListener('input', (e) => {
        offsetXValue.textContent = e.target.value;
        updateSplatPosition();
      });
    }

    if (offsetYInput) {
      offsetYInput.addEventListener('input', (e) => {
        offsetYValue.textContent = e.target.value;
        updateSplatPosition();
      });
    }

    if (offsetZInput) {
      offsetZInput.addEventListener('input', (e) => {
        offsetZValue.textContent = e.target.value;
        updateSplatPosition();
      });
    }

    // ===== GTA-style controls: first-person / third-person with WASD =====
    const firstPersonBtn = document.getElementById("first-person-btn");
    const thirdPersonBtn = document.getElementById("third-person-btn");
    const droneBtn = document.getElementById("drone-view-btn");

    let viewMode = "first"; // "first" | "third" | "drone"
    let yaw = 0;
    let pitch = 0;
    const yawSpeed = 0.0025;
    const pitchSpeed = 0.0025;
    const maxPitch = Math.PI / 2 - 0.1;

    const keys = { w: false, a: false, s: false, d: false };
    const walkSpeed = 5.0; // meters / second
    const droneSpeed = 6.0;
    const firstPersonEyeHeight = 1.45;

    let lastTime = performance.now();
    let isMouseDown = false;
    let lastMouseX = 0;
    let lastMouseY = 0;

    const dronePosition = new THREE.Vector3(
      boundsData.center?.[0] ?? 0,
      floorY + 3,
      (boundsData.center?.[2] ?? 0) + 6,
    );

    function setViewMode(mode) {
      viewMode = mode;
      player.visible = mode !== "first";
      if (firstPersonBtn && thirdPersonBtn && droneBtn) {
        firstPersonBtn.classList.toggle("active", mode === "first");
        thirdPersonBtn.classList.toggle("active", mode === "third");
        droneBtn.classList.toggle("active", mode === "drone");
      }
    }

    if (firstPersonBtn && thirdPersonBtn && droneBtn) {
      firstPersonBtn.addEventListener("click", () => setViewMode("first"));
      thirdPersonBtn.addEventListener("click", () => setViewMode("third"));
      droneBtn.addEventListener("click", () => setViewMode("drone"));
    }

    let lastKey = "None";
    window.addEventListener("keydown", (event) => {
      lastKey = event.code;
      if (event.code === "KeyW") keys.w = true;
      if (event.code === "KeyA") keys.a = true;
      if (event.code === "KeyS") keys.s = true;
      if (event.code === "KeyD") keys.d = true;
      if (event.code === "Space") keys[' '] = true;
    });

    window.addEventListener("keyup", (event) => {
      if (event.code === "KeyW") keys.w = false;
      if (event.code === "KeyA") keys.a = false;
      if (event.code === "KeyS") keys.s = false;
      if (event.code === "KeyD") keys.d = false;
      if (event.code === "Space") keys[' '] = false;
    });

    renderer.domElement.addEventListener("mousedown", (event) => {
      isMouseDown = true;
      lastMouseX = event.clientX;
      lastMouseY = event.clientY;
    });

    window.addEventListener("mouseup", () => {
      isMouseDown = false;
    });

    window.addEventListener("mousemove", (event) => {
      if (!isMouseDown) return;
      const dx = event.clientX - lastMouseX;
      const dy = event.clientY - lastMouseY;
      lastMouseX = event.clientX;
      lastMouseY = event.clientY;

      yaw -= dx * yawSpeed;
      pitch -= dy * pitchSpeed;
      pitch = Math.max(-maxPitch, Math.min(maxPitch, pitch));
    });

    function getForwardVector(includePitch = false) {
      if (includePitch) {
        return new THREE.Vector3(
          Math.sin(yaw) * Math.cos(pitch),
          Math.sin(pitch),
          Math.cos(yaw) * Math.cos(pitch),
        ).normalize();
      }
      return new THREE.Vector3(Math.sin(yaw), 0, Math.cos(yaw)).normalize();
    }

    function getRightVector() {
      return new THREE.Vector3(Math.cos(yaw), 0, -Math.sin(yaw)).normalize();
    }

    function clampToBounds(vector) {
      vector.x = Math.max(worldBounds.x[0], Math.min(worldBounds.x[1], vector.x));
      vector.z = Math.max(worldBounds.z[0], Math.min(worldBounds.z[1], vector.z));
      // No obstacle box check here anymore
    }

    function getGridCell(x, z) {
      if (!gridMetadata || !collisionMap) return null;
      const c = Math.floor((x - gridMetadata.min_x) / gridMetadata.grid_size);
      const r = Math.floor((z - gridMetadata.min_z) / gridMetadata.grid_size);
      const key = `${c},${r}`;
      return collisionMap[key];
    }

    function checkCollision(x, z) {
      // Check grid-based collision
      const cell = getGridCell(x, z);
      if (cell && cell.b === 1) return true;

      // Check mesh collision (use player height approx)
      // We assume player is around y=1.0 relative to floor for body check
      // But for general checkCollision(x,z) we might need a Y.
      // Let's use a default Y or pass it in.
      // For now, let's assume we are checking at a relevant height.
      // But wait, checkCollision(x,z) is 2D.
      // We should probably update checkCollision to take Y or check a range.
      // However, updatePlayer calls getGridCell directly.

      // Let's keep this simple: checkCollision checks grid.
      // We will add explicit mesh checks in updatePlayer/updateDrone.
      return false;
    }



    function updateDrone(dt) {
      if (viewMode !== "drone") return;
      const forwardDir = getForwardVector(true);
      const rightDir = getRightVector();
      let move = new THREE.Vector3();

      if (keys.w) move.add(forwardDir);
      if (keys.s) move.sub(forwardDir);
      if (keys.a) move.sub(rightDir);
      if (keys.d) move.add(rightDir);

      const noclip = document.getElementById('noclip')?.checked;
      let blocked = false;

      if (move.lengthSq() > 0) {
        move.normalize().multiplyScalar(droneSpeed * dt);

        const nextPos = dronePosition.clone().add(move);

        // Check mesh collision for drone too
        if (noclip || !checkMeshCollision(nextPos.x, nextPos.y, nextPos.z)) {
          dronePosition.add(move);
        } else {
          blocked = true;
        }
      }

      dronePosition.y = Math.max(floorY + 0.5, Math.min(worldBounds.y[1], dronePosition.y));
      clampToBounds(dronePosition);

      // Update debug info for drone
      const debugDiv = document.getElementById('movement-debug');
      if (debugDiv) {
        debugDiv.innerHTML = `
          View: ${viewMode}<br>
          Keys: W:${keys.w} A:${keys.a} S:${keys.s} D:${keys.d}<br>
          Pos: ${dronePosition.x.toFixed(2)}, ${dronePosition.y.toFixed(2)}, ${dronePosition.z.toFixed(2)}<br>
          Blocked: ${blocked ? 'YES' : 'NO'}<br>
          Noclip: ${noclip ? 'ON' : 'OFF'}<br>
          Bounds X: [${worldBounds.x[0].toFixed(1)}, ${worldBounds.x[1].toFixed(1)}]<br>
          Bounds Z: [${worldBounds.z[0].toFixed(1)}, ${worldBounds.z[1].toFixed(1)}]<br>
        `;
      }
    }

    function updateCamera() {
      if (viewMode === "first") {
        camera.position.set(
          player.position.x,
          player.position.y + firstPersonEyeHeight,
          player.position.z,
        );
        const lookDir = getForwardVector(true);
        const target = new THREE.Vector3().copy(camera.position).add(lookDir);
        camera.lookAt(target);
      } else if (viewMode === "third") {
        const offset = new THREE.Vector3(0, 2.0, 6.0);
        const rotY = new THREE.Matrix4().makeRotationY(yaw);
        offset.applyMatrix4(rotY);

        const focus = new THREE.Vector3(
          player.position.x,
          player.position.y + 1.4,
          player.position.z,
        );
        const camPos = new THREE.Vector3().copy(focus).add(offset);
        camera.position.copy(camPos);
        camera.lookAt(focus);
      } else {
        camera.position.copy(dronePosition);
        const lookDir = getForwardVector(true);
        const target = new THREE.Vector3().copy(dronePosition).add(lookDir);
        camera.lookAt(target);
      }
    }

    // ===== MESH TOOLS SYSTEM =====
    let activeTool = 'none'; // 'none' | 'sphere' | 'box' | 'brush'
    let createdMeshes = [];
    let meshIdCounter = 0;
    let previewMesh = null;
    let previewSplatEdit = null; // For highlighting selection
    let isCreating = false;
    let creationStart = null;
    let brushPoints = [];

    // Tool settings
    let sphereRadius = 2.0;
    let boxWidth = 3.0;
    let boxHeight = 2.5;
    let boxDepth = 3.0;
    let brushWidth = 1.0;

    // Material for collision meshes
    const collisionMaterial = new THREE.MeshStandardMaterial({
      color: 0xff4444,
      transparent: true,
      opacity: 0.5,
      roughness: 0.3,
      metalness: 0.1
    });

    const previewMaterial = new THREE.MeshStandardMaterial({
      color: 0x7f5cff,
      transparent: true,
      opacity: 0.3,
      wireframe: false
    });

    // Get UI elements
    const toolBtns = {
      none: document.getElementById('tool-none'),
      sphere: document.getElementById('tool-sphere'),
      box: document.getElementById('tool-box'),
      brush: document.getElementById('tool-brush')
    };

    const sphereSizeInput = document.getElementById('sphere-size');
    const sphereSizeValue = document.getElementById('sphere-size-value');
    const boxWidthInput = document.getElementById('box-width');
    const boxWidthValue = document.getElementById('box-width-value');
    const boxHeightInput = document.getElementById('box-height');
    const boxHeightValue = document.getElementById('box-height-value');
    const boxDepthInput = document.getElementById('box-depth');
    const boxDepthValue = document.getElementById('box-depth-value');
    const brushWidthInput = document.getElementById('brush-width');
    const brushWidthValue = document.getElementById('brush-width-value');
    const showCreatedMeshesCheckbox = document.getElementById('show-created-meshes');
    const showSelectionHighlightCheckbox = document.getElementById('show-selection-highlight');
    const toolHint = document.getElementById('tool-hint');
    const meshCount = document.getElementById('mesh-count');
    const meshItems = document.getElementById('mesh-items');

    // Tool hints
    const toolHints = {
      none: 'Select a tool to create collision meshes',
      sphere: 'Click and drag to create a sphere. Drag distance sets the radius.',
      box: 'Click and drag to create a box. Drag distance sets the size.',
      brush: 'Click and drag to paint a collision path along your mouse movement.'
    };

    // Set active tool
    function setActiveTool(tool) {
      activeTool = tool;
      Object.keys(toolBtns).forEach(key => {
        toolBtns[key]?.classList.toggle('active', key === tool);
      });
      toolHint.textContent = toolHints[tool];

      // Show/hide relevant settings
      document.getElementById('sphere-size-label').style.display = tool === 'sphere' ? 'block' : 'none';
      document.getElementById('box-width-label').style.display = tool === 'box' ? 'block' : 'none';
      document.getElementById('box-height-label').style.display = tool === 'box' ? 'block' : 'none';
      document.getElementById('box-depth-label').style.display = tool === 'box' ? 'block' : 'none';
      document.getElementById('brush-width-label').style.display = tool === 'brush' ? 'block' : 'none';

      // Clear any ongoing creation
      clearPreview();
    }

    // Hook up tool buttons
    Object.keys(toolBtns).forEach(tool => {
      toolBtns[tool]?.addEventListener('click', () => setActiveTool(tool));
    });

    // Hook up settings inputs
    sphereSizeInput?.addEventListener('input', (e) => {
      sphereRadius = parseFloat(e.target.value);
      sphereSizeValue.textContent = sphereRadius.toFixed(1);
    });

    boxWidthInput?.addEventListener('input', (e) => {
      boxWidth = parseFloat(e.target.value);
      boxWidthValue.textContent = boxWidth.toFixed(1);
    });

    boxHeightInput?.addEventListener('input', (e) => {
      boxHeight = parseFloat(e.target.value);
      boxHeightValue.textContent = boxHeight.toFixed(1);
    });

    boxDepthInput?.addEventListener('input', (e) => {
      boxDepth = parseFloat(e.target.value);
      boxDepthValue.textContent = boxDepth.toFixed(1);
    });

    brushWidthInput?.addEventListener('input', (e) => {
      brushWidth = parseFloat(e.target.value);
      brushWidthValue.textContent = brushWidth.toFixed(1);
    });

    // Initialize tool settings display
    setActiveTool('none');

    // Toggle visibility of created meshes
    if (showCreatedMeshesCheckbox) {
      showCreatedMeshesCheckbox.addEventListener('change', (e) => {
        const visible = e.target.checked;
        createdMeshes.forEach(m => {
          m.mesh.visible = visible;
        });
      });
    }

    // Toggle visibility of selection highlight (yellow)
    if (showSelectionHighlightCheckbox) {
      showSelectionHighlightCheckbox.addEventListener('change', (e) => {
        const visible = e.target.checked;
        if (!currentSplat || !currentSplat.edits) return;

        createdMeshes.forEach(m => {
          if (m.data.splatEdit) {
            const editIdx = currentSplat.edits.indexOf(m.data.splatEdit);
            if (visible && editIdx === -1) {
              // Add back if missing
              currentSplat.edits.push(m.data.splatEdit);
            } else if (!visible && editIdx !== -1) {
              // Remove if present
              currentSplat.edits.splice(editIdx, 1);
            }
          }
        });
      });
    }

    // Raycaster for mouse interaction
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    // Get 3D position from mouse
    function getWorldPosition(event) {
      const rect = renderer.domElement.getBoundingClientRect();
      mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

      raycaster.setFromCamera(mouse, camera);

      // 1. Try raycasting against the splat mesh first
      if (currentSplat) {
        const intersects = [];
        currentSplat.raycast(raycaster, intersects);
        if (intersects.length > 0) {
          // Sort by distance
          intersects.sort((a, b) => a.distance - b.distance);
          return intersects[0].point;
        }
      }

      // 2. Fallback: Create an invisible ground plane to raycast against
      const planeY = floorY;
      const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), -planeY);
      const intersection = new THREE.Vector3();
      raycaster.ray.intersectPlane(plane, intersection);

      return intersection;
    }

    function clearPreview() {
      if (previewMesh) {
        scene.remove(previewMesh);
        previewMesh = null;
      }
      if (previewSplatEdit && currentSplat) {
        // Remove edit from splat if it's still the preview one
        if (currentSplat.edits) {
          const idx = currentSplat.edits.indexOf(previewSplatEdit);
          if (idx !== -1) currentSplat.edits.splice(idx, 1);
        }
        previewSplatEdit = null;
      }
      brushPoints = [];
    }

    function addBrushCapsule(start, end, radius) {
      if (!currentSplat) return;

      // Initialize preview edit if needed
      if (!previewSplatEdit) {
        previewSplatEdit = new SplatEdit({
          rgbaBlendMode: SplatEditRgbaBlendMode.SET_RGB,
          sdfs: [],
          softEdge: 0.2, // Softer edge for brush
          name: 'Brush Selection'
        });

        if (!currentSplat.edits) currentSplat.edits = [];
        currentSplat.edits.push(previewSplatEdit);
      }

      const center = new THREE.Vector3().addVectors(start, end).multiplyScalar(0.5);
      const direction = new THREE.Vector3().subVectors(end, start);
      const length = direction.length();

      if (length < 0.001) return;

      direction.normalize();

      // Align Y axis with direction
      const quaternion = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), direction);

      // Transform to local space
      const splatInverse = currentSplat.matrixWorld.clone().invert();
      const localPos = center.clone().applyMatrix4(splatInverse);
      const localRot = quaternion.clone().multiply(currentSplat.quaternion.clone().invert());

      // Create Capsule SDF
      const sdf = new SplatEditSdf({
        type: SplatEditSdfType.CAPSULE,
        opacity: 0.6, // Semi-transparent yellow
        color: new THREE.Color(1.0, 1.0, 0.0), // Yellow
        radius: radius,
        displace: new THREE.Vector3(0, 0, 0)
      });

      // Set transform
      sdf.position.copy(center); // Using world position as SplatEdit handles transform? 
      // Wait, in updatePreviewSplatEdit I saw: 
      // sdf.position.copy(position);
      // And the comment: "For now, let's assume Splat is at origin/identity"
      // If Splat is at origin, world == local.
      // But if Splat is moved, we need to be careful.
      // The SplatEdit system seems to expect world space transforms for the SDFs if they are children of the scene?
      // No, SplatEditSdf is a child of SplatEdit? No, SplatEdit has a list of SDFs.
      // SplatEditSdf extends Object3D.
      // If they are not added to the scene graph, their matrixWorld is not auto-updated by Three.js renderer unless we do it.
      // SplatEdit.ts calls `sdf.updateMatrixWorld()` manually.
      // And it sets `sdf.scale` based on sizes.

      sdf.position.copy(center);
      sdf.quaternion.copy(quaternion);
      sdf.scale.set(radius, length, radius); // y is length

      previewSplatEdit.addSdf(sdf);
    }

    function updatePreviewSplatEdit(type, position, rotation, scale, radius) {
      if (!currentSplat) return;

      // Create edit if not exists
      if (!previewSplatEdit) {
        const sdf = new SplatEditSdf({
          type: type === 'sphere' ? SplatEditSdfType.SPHERE : SplatEditSdfType.BOX,
          opacity: 0.6,
          color: new THREE.Color(1.0, 1.0, 0.0), // Yellow
          radius: 0.0
        });

        previewSplatEdit = new SplatEdit({
          rgbaBlendMode: SplatEditRgbaBlendMode.SET_RGB,
          sdfs: [sdf],
          softEdge: 0.1
        });

        if (!currentSplat.edits) currentSplat.edits = [];
        currentSplat.edits.push(previewSplatEdit);
      }

      // Update SDF properties (assuming single SDF for sphere/box)
      if (previewSplatEdit.sdfs.length === 0) {
        const sdf = new SplatEditSdf({
          type: type === 'sphere' ? SplatEditSdfType.SPHERE : SplatEditSdfType.BOX,
          opacity: 0.6,
          color: new THREE.Color(1.0, 1.0, 0.0), // Yellow
          radius: 0.0
        });
        previewSplatEdit.addSdf(sdf);
      }

      const sdf = previewSplatEdit.sdfs[0];
      sdf.type = type === 'sphere' ? SplatEditSdfType.SPHERE : SplatEditSdfType.BOX;
      sdf.color.setHex(0xFFFF00); // Ensure yellow

      sdf.position.copy(position);
      sdf.rotation.copy(rotation);

      if (type === 'sphere') {
        sdf.radius = radius;
        sdf.scale.setScalar(1);
      } else {
        sdf.scale.copy(scale);
        sdf.radius = 0.1; // Rounding for box
      }
    }

    function createSphere(center, radius) {
      const geometry = new THREE.SphereGeometry(radius, 32, 32);
      const mesh = new THREE.Mesh(geometry, collisionMaterial.clone());
      mesh.position.copy(center);
      return mesh;
    }

    function createBox(center, width, height, depth) {
      const geometry = new THREE.BoxGeometry(width, height, depth);
      const mesh = new THREE.Mesh(geometry, collisionMaterial.clone());
      mesh.position.copy(center);
      mesh.position.y += height / 2; // Align bottom to floor
      return mesh;
    }

    // ===== POINT-TO-MESH COLLISION SYSTEM =====

    // Helper: Calculate distance from point to line segment
    function distanceToLineSegment(point, segmentStart, segmentEnd) {
      const line = new THREE.Vector3().subVectors(segmentEnd, segmentStart);
      const lineLength = line.length();

      if (lineLength === 0) {
        return point.distanceTo(segmentStart);
      }

      const t = Math.max(0, Math.min(1,
        new THREE.Vector3().subVectors(point, segmentStart).dot(line) / (lineLength * lineLength)
      ));

      const projection = new THREE.Vector3().addVectors(
        segmentStart,
        line.multiplyScalar(t)
      );

      return point.distanceTo(projection);
    }

    // Helper: Calculate bounding box of points
    function calculateBounds(points) {
      let minX = Infinity, maxX = -Infinity;
      let minY = Infinity, maxY = -Infinity;
      let minZ = Infinity, maxZ = -Infinity;

      for (const p of points) {
        if (p.x < minX) minX = p.x;
        if (p.x > maxX) maxX = p.x;
        if (p.y < minY) minY = p.y;
        if (p.y > maxY) maxY = p.y;
        if (p.z < minZ) minZ = p.z;
        if (p.z > maxZ) maxZ = p.z;
      }

      return { minX, maxX, minY, maxY, minZ, maxZ };
    }

    // Extract splat points that fall within brush selection area
    function getPointsInBrushArea(splatMesh, brushPoints, brushWidth) {
      if (!splatMesh) {
        console.warn('No splat mesh provided');
        return [];
      }

      // Try to access geometry data from SplatMesh
      let positions = null;

      // Debug: Log structure to understand how to access points
      console.log('SplatMesh structure:', {
        hasGeometry: !!splatMesh.geometry,
        hasAttributes: splatMesh.geometry?.attributes ? Object.keys(splatMesh.geometry.attributes) : 'none',
        geometryType: splatMesh.geometry?.type,
        splatMeshType: splatMesh.constructor?.name
      });

      // Try different ways to access positions
      if (splatMesh.geometry?.attributes?.position) {
        positions = splatMesh.geometry.attributes.position;
        console.log('Found positions via geometry.attributes.position');
      } else if (splatMesh.geometry?.getAttribute) {
        try {
          positions = splatMesh.geometry.getAttribute('position');
          console.log('Found positions via getAttribute');
        } catch (e) {
          console.warn('getAttribute failed:', e.message);
        }
      }

      if (!positions) {
        console.error('Could not access splat positions. Available properties:', Object.keys(splatMesh));
        return [];
      }

      const selectedPoints = [];
      const radius = brushWidth / 2;

      console.log(`Checking ${positions.count} points against brush area (radius: ${radius})`);

      // For each splat point
      for (let i = 0; i < positions.count; i++) {
        const x = positions.getX(i);
        const y = positions.getY(i);
        const z = positions.getZ(i);
        const point = new THREE.Vector3(x, y, z);

        // Check if point is near any segment of the brush path
        for (let j = 0; j < brushPoints.length - 1; j++) {
          const segmentStart = brushPoints[j];
          const segmentEnd = brushPoints[j + 1];

          // Calculate distance from point to line segment
          const dist = distanceToLineSegment(point, segmentStart, segmentEnd);

          if (dist <= radius) {
            selectedPoints.push(point.clone());
            break; // Don't add the same point multiple times
          }
        }
      }
      console.log(`Selected ${selectedPoints.length} points from splat`);
      return selectedPoints;
    }

    // Extract splat points that fall within a spherical region
    function getPointsInSphere(splatMesh, center, radius) {
      if (!splatMesh) {
        console.warn('No splat mesh provided');
        return [];
      }

      let positions = null;

      // Try to access positions
      if (splatMesh.geometry?.attributes?.position) {
        positions = splatMesh.geometry.attributes.position;
      } else if (splatMesh.geometry?.getAttribute) {
        try {
          positions = splatMesh.geometry.getAttribute('position');
        } catch (e) {
          console.warn('getAttribute failed:', e.message);
        }
      }

      if (!positions) {
        console.error('Could not access splat positions');
        return [];
      }

      const selectedPoints = [];
      console.log(`Checking ${positions.count} points against sphere (center: ${center.x.toFixed(2)}, ${center.y.toFixed(2)}, ${center.z.toFixed(2)}, radius: ${radius.toFixed(2)})`);

      // For each splat point, check if it's within the sphere
      for (let i = 0; i < positions.count; i++) {
        const x = positions.getX(i);
        const y = positions.getY(i);
        const z = positions.getZ(i);
        const point = new THREE.Vector3(x, y, z);

        const distance = point.distanceTo(center);
        if (distance <= radius) {
          selectedPoints.push(point.clone());
        }
      }

      console.log(`Selected ${selectedPoints.length} points from splat in sphere`);
      return selectedPoints;
    }

    // Extract splat points that fall within a box region
    function getPointsInBox(splatMesh, center, width, height, depth) {
      if (!splatMesh) {
        console.warn('No splat mesh provided');
        return [];
      }

      let positions = null;

      // Try to access positions
      if (splatMesh.geometry?.attributes?.position) {
        positions = splatMesh.geometry.attributes.position;
      } else if (splatMesh.geometry?.getAttribute) {
        try {
          positions = splatMesh.geometry.getAttribute('position');
        } catch (e) {
          console.warn('getAttribute failed:', e.message);
        }
      }

      if (!positions) {
        console.error('Could not access splat positions');
        return [];
      }

      const selectedPoints = [];
      const halfWidth = width / 2;
      const halfHeight = height / 2;
      const halfDepth = depth / 2;

      console.log(`Checking ${positions.count} points against box (center: ${center.x.toFixed(2)}, ${center.y.toFixed(2)}, ${center.z.toFixed(2)}, size: ${width.toFixed(2)}x${height.toFixed(2)}x${depth.toFixed(2)})`);

      // For each splat point, check if it's within the box bounds
      for (let i = 0; i < positions.count; i++) {
        const x = positions.getX(i);
        const y = positions.getY(i);
        const z = positions.getZ(i);
        const point = new THREE.Vector3(x, y, z);

        // Check if point is within box bounds
        const dx = Math.abs(point.x - center.x);
        const dy = Math.abs(point.y - center.y);
        const dz = Math.abs(point.z - center.z);

        if (dx <= halfWidth && dy <= halfHeight && dz <= halfDepth) {
          selectedPoints.push(point.clone());
        }
      }

      console.log(`Selected ${selectedPoints.length} points from splat in box`);
      return selectedPoints;
    }

    // Create convex hull collision mesh from points
    function createConvexHullFromPoints(points) {
      if (points.length === 0) {
        console.warn('No points to create convex hull from');
        return null;
      }

      console.log(`Creating convex hull collision mesh from ${points.length} points`);

      // Create convex hull using ConvexGeometry
      try {
        const convexGeometry = new ConvexGeometry(points);

        console.log(`Created convex hull collision mesh with ${convexGeometry.attributes.position.count} vertices`);

        const material = new THREE.MeshStandardMaterial({
          color: 0xff4444,
          transparent: true,
          opacity: 0.0,
          side: THREE.DoubleSide
        });

        const mesh = new THREE.Mesh(convexGeometry, material);
        return mesh;
      } catch (error) {
        console.error('Error creating convex hull geometry:', error);
        console.error('Falling back to simple bounding box');

        // Fallback: create a simple bounding box
        const bounds = calculateBounds(points);
        const width = bounds.maxX - bounds.minX;
        const height = bounds.maxY - bounds.minY;
        const depth = bounds.maxZ - bounds.minZ;

        const boxGeometry = new THREE.BoxGeometry(width, height, depth);
        const material = new THREE.MeshStandardMaterial({
          color: 0xff4444,
          transparent: true,
          opacity: 0.0,
          side: THREE.DoubleSide
        });

        const mesh = new THREE.Mesh(boxGeometry, material);
        mesh.position.set(
          (bounds.minX + bounds.maxX) / 2,
          (bounds.minY + bounds.maxY) / 2,
          (bounds.minZ + bounds.maxZ) / 2
        );

        return mesh;
      }
    }

    // Create collision mesh directly from brush points using convex hull
    function createCollisionMeshFromBrushPoints(points, brushWidth) {
      if (points.length === 0) {
        console.warn('No points to create mesh from');
        return null;
      }

      console.log(`Creating convex hull collision mesh from ${points.length} brush points (width: ${brushWidth}m)`);

      // Create a set of vertices around the brush path
      const vertices = [];
      const radius = brushWidth / 2;

      // For each point, create a ring of vertices around it
      const radialSegments = 8; // octagon around each point

      for (let i = 0; i < points.length; i++) {
        const point = points[i];

        // Get direction for perpendicular orientation
        let forward, right, up;

        if (i < points.length - 1) {
          forward = new THREE.Vector3().subVectors(points[i + 1], point).normalize();
        } else if (i > 0) {
          forward = new THREE.Vector3().subVectors(point, points[i - 1]).normalize();
        } else {
          forward = new THREE.Vector3(0, 1, 0);
        }

        // Create perpendicular vectors
        if (Math.abs(forward.y) < 0.99) {
          up = new THREE.Vector3(0, 1, 0);
        } else {
          up = new THREE.Vector3(1, 0, 0);
        }
        right = new THREE.Vector3().crossVectors(forward, up).normalize();
        up = new THREE.Vector3().crossVectors(right, forward).normalize();

        // Create ring of vertices around this point
        for (let j = 0; j < radialSegments; j++) {
          const angle = (j / radialSegments) * Math.PI * 2;
          const cos = Math.cos(angle);
          const sin = Math.sin(angle);

          const vertex = new THREE.Vector3(
            point.x + (right.x * cos + up.x * sin) * radius,
            point.y + (right.y * cos + up.y * sin) * radius,
            point.z + (right.z * cos + up.z * sin) * radius
          );

          vertices.push(vertex);
        }
      }

      // Also add the center points for better hull shape
      for (const point of points) {
        vertices.push(point.clone());
      }

      console.log(`Generated ${vertices.length} vertices for convex hull`);

      // Create convex hull using ConvexGeometry
      try {
        const convexGeometry = new ConvexGeometry(vertices);

        console.log(`Created convex hull collision mesh with ${convexGeometry.attributes.position.count} vertices`);

        const material = new THREE.MeshStandardMaterial({
          color: 0xff4444,
          transparent: true,
          opacity: 0.0,
          side: THREE.DoubleSide
        });

        const mesh = new THREE.Mesh(convexGeometry, material);
        return mesh;
      } catch (error) {
        console.error('Error creating convex hull geometry:', error);
        console.error('Falling back to simple bounding box');

        // Fallback: create a simple bounding box
        const bounds = calculateBounds(points);
        const width = bounds.maxX - bounds.minX + brushWidth;
        const height = bounds.maxY - bounds.minY + brushWidth;
        const depth = bounds.maxZ - bounds.minZ + brushWidth;

        const boxGeometry = new THREE.BoxGeometry(width, height, depth);
        const material = new THREE.MeshStandardMaterial({
          color: 0xff4444,
          transparent: true,
          opacity: 0.0,
          side: THREE.DoubleSide
        });

        const mesh = new THREE.Mesh(boxGeometry, material);
        mesh.position.set(
          (bounds.minX + bounds.maxX) / 2,
          (bounds.minY + bounds.maxY) / 2,
          (bounds.minZ + bounds.maxZ) / 2
        );

        return mesh;
      }
    }

    // REMOVED: evaluateSDF - no longer needed for brush collision

    // REMOVED: samplePointsFromSDF - no longer needed with direct tube collision

    // REMOVED: createMeshFromSplatEditSDF - replaced with direct createCollisionMeshFromBrushPoints

    function createBrushStroke(points, width) {

      // Create a tube geometry along the path
      const curve = new THREE.CatmullRomCurve3(points);
      const geometry = new THREE.TubeGeometry(curve, points.length * 2, width / 2, 8, false);
      const mesh = new THREE.Mesh(geometry, collisionMaterial.clone());
      return mesh;
    }

    function addMesh(mesh, type, data) {
      const id = meshIdCounter++;
      const meshData = {
        id: id,
        type: type,
        mesh: mesh,
        data: data
      };

      createdMeshes.push(meshData);

      // Respect current visibility setting - REMOVED to keep meshes invisible by default
      // if (showCreatedMeshesCheckbox) {
      //   mesh.visible = showCreatedMeshesCheckbox.checked;
      // }

      scene.add(mesh);
      updateMeshList();

      console.log(`Created ${type} mesh #${id}`);
    }

    function deleteMesh(id) {
      const index = createdMeshes.findIndex(m => m.id === id);
      if (index !== -1) {
        const meshData = createdMeshes[index];
        scene.remove(meshData.mesh);

        // Remove associated SplatEdit if exists
        if (meshData.data.splatEdit && currentSplat && currentSplat.edits) {
          const editIdx = currentSplat.edits.indexOf(meshData.data.splatEdit);
          if (editIdx !== -1) {
            currentSplat.edits.splice(editIdx, 1);
          }
        }

        createdMeshes.splice(index, 1);
        updateMeshList();
      }
    }

    function clearAllMeshes() {
      createdMeshes.forEach(m => {
        scene.remove(m.mesh);
        // Remove associated SplatEdit if exists
        if (m.data.splatEdit && currentSplat && currentSplat.edits) {
          const editIdx = currentSplat.edits.indexOf(m.data.splatEdit);
          if (editIdx !== -1) {
            currentSplat.edits.splice(editIdx, 1);
          }
        }
      });
      createdMeshes = [];
      updateMeshList();
    }

    function updateMeshList() {
      meshCount.textContent = createdMeshes.length;
      meshItems.innerHTML = '';

      createdMeshes.forEach(meshData => {
        const item = document.createElement('div');
        item.className = 'mesh-item';

        const info = document.createElement('div');
        info.className = 'mesh-item-info';

        const typeSpan = document.createElement('span');
        typeSpan.className = 'mesh-item-type';
        typeSpan.textContent = meshData.type;

        const pos = meshData.mesh.position;
        const posText = document.createTextNode(` (${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}, ${pos.z.toFixed(1)})`);

        info.appendChild(typeSpan);
        info.appendChild(posText);

        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'delete-mesh-btn';
        deleteBtn.textContent = 'Delete';
        deleteBtn.addEventListener('click', () => deleteMesh(meshData.id));

        item.appendChild(info);
        item.appendChild(deleteBtn);
        meshItems.appendChild(item);
      });
    }

    // Export/Import functionality
    document.getElementById('export-meshes')?.addEventListener('click', () => {
      const data = createdMeshes.map(m => {
        // Create a serializable data object
        const serializedData = { ...m.data };

        // Convert Vector3 objects to plain objects for serialization
        if (serializedData.center && serializedData.center.isVector3) {
          serializedData.center = { x: serializedData.center.x, y: serializedData.center.y, z: serializedData.center.z };
        }

        if (serializedData.points && Array.isArray(serializedData.points)) {
          serializedData.points = serializedData.points.map(p =>
            p.isVector3 ? { x: p.x, y: p.y, z: p.z } : p
          );
        }

        // Remove non-serializable objects
        delete serializedData.splatEdit;

        return {
          type: m.type,
          position: { x: m.mesh.position.x, y: m.mesh.position.y, z: m.mesh.position.z },
          rotation: { x: m.mesh.rotation.x, y: m.mesh.rotation.y, z: m.mesh.rotation.z },
          data: serializedData
        };
      });

      const json = JSON.stringify(data, null, 2);
      const blob = new Blob([json], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'collision_meshes.json';
      a.click();
      URL.revokeObjectURL(url);
    });

    document.getElementById('import-meshes')?.addEventListener('click', () => {
      document.getElementById('mesh-import-input').click();
    });

    document.getElementById('mesh-import-input')?.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = (event) => {
        try {
          const data = JSON.parse(event.target.result);
          clearAllMeshes();

          data.forEach(item => {
            let mesh = null;
            if (item.type === 'sphere') {
              mesh = createSphere(
                new THREE.Vector3(item.position.x, item.position.y, item.position.z),
                item.data.radius
              );
            } else if (item.type === 'box') {
              mesh = createBox(
                new THREE.Vector3(item.position.x, item.position.y, item.position.z),
                item.data.width,
                item.data.height,
                item.data.depth
              );
              mesh.rotation.set(item.rotation.x, item.rotation.y, item.rotation.z);
            } else if (item.type === 'brush') {
              const points = item.data.points.map(p => new THREE.Vector3(p.x, p.y, p.z));
              mesh = createBrushStroke(points, item.data.width);
            }

            if (mesh) {
              addMesh(mesh, item.type, item.data);
            }
          });
        } catch (err) {
          console.error('Failed to import meshes:', err);
        }
      };
      reader.readAsText(file);
    });

    document.getElementById('clear-meshes')?.addEventListener('click', () => {
      if (confirm('Delete all created meshes?')) {
        clearAllMeshes();
      }
    });

    // Export complete scene (PLY + offsets + collision grid + meshes)
    document.getElementById('export-scene')?.addEventListener('click', () => {
      const sceneData = {
        version: '1.0',
        ply: {
          url: currentSplat?.url || null,
          fileName: currentSplat?.fileName || null,
          offsets: {
            x: parseFloat(document.getElementById('offset-x')?.value || 0),
            y: parseFloat(document.getElementById('offset-y')?.value || 0),
            z: parseFloat(document.getElementById('offset-z')?.value || 0)
          }
        },
        collisionGrid: {
          metadata: gridMetadata,
          map: collisionMap
        },
        meshes: createdMeshes.map(m => {
          // Create a serializable data object
          const serializedData = { ...m.data };

          // Convert Vector3 objects to plain objects for serialization
          if (serializedData.center && serializedData.center.isVector3) {
            serializedData.center = { x: serializedData.center.x, y: serializedData.center.y, z: serializedData.center.z };
          }

          if (serializedData.points && Array.isArray(serializedData.points)) {
            serializedData.points = serializedData.points.map(p =>
              p.isVector3 ? { x: p.x, y: p.y, z: p.z } : p
            );
          }

          // Remove non-serializable objects
          delete serializedData.splatEdit;

          return {
            type: m.type,
            position: { x: m.mesh.position.x, y: m.mesh.position.y, z: m.mesh.position.z },
            rotation: { x: m.mesh.rotation.x, y: m.mesh.rotation.y, z: m.mesh.rotation.z },
            data: serializedData
          };
        })
      };

      const json = JSON.stringify(sceneData, null, 2);
      const blob = new Blob([json], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'scene_complete.json';
      a.click();
      URL.revokeObjectURL(url);

      console.log('Exported complete scene:', sceneData);
    });

    // Import meshes only
    document.getElementById('import-meshes')?.addEventListener('click', () => {
      document.getElementById('mesh-import-input').click();
    });

    // Import complete scene
    document.getElementById('import-scene')?.addEventListener('click', () => {
      document.getElementById('scene-import-input').click();
    });

    document.getElementById('scene-import-input')?.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = (event) => {
        try {
          const sceneData = JSON.parse(event.target.result);

          console.log('Importing complete scene:', sceneData);

          // Import PLY and offsets
          if (sceneData.ply && sceneData.ply.url) {
            loadSplat(sceneData.ply.url, sceneData.ply.fileName);

            // Set offsets
            if (sceneData.ply.offsets) {
              const offsetXInput = document.getElementById('offset-x');
              const offsetYInput = document.getElementById('offset-y');
              const offsetZInput = document.getElementById('offset-z');
              const offsetXValue = document.getElementById('offset-x-value');
              const offsetYValue = document.getElementById('offset-y-value');
              const offsetZValue = document.getElementById('offset-z-value');

              if (offsetXInput) {
                offsetXInput.value = sceneData.ply.offsets.x;
                offsetXValue.textContent = sceneData.ply.offsets.x;
              }
              if (offsetYInput) {
                offsetYInput.value = sceneData.ply.offsets.y;
                offsetYValue.textContent = sceneData.ply.offsets.y;
              }
              if (offsetZInput) {
                offsetZInput.value = sceneData.ply.offsets.z;
                offsetZValue.textContent = sceneData.ply.offsets.z;
              }

              // Apply offsets to the loaded splat
              setTimeout(() => {
                if (currentSplat) {
                  currentSplat.position.set(
                    sceneData.ply.offsets.x,
                    sceneData.ply.offsets.y,
                    sceneData.ply.offsets.z
                  );
                }
              }, 500);
            }
          }

          // Import collision grid
          if (sceneData.collisionGrid) {
            if (sceneData.collisionGrid.metadata) {
              gridMetadata = sceneData.collisionGrid.metadata;
              floorY = gridMetadata.min_y || 0;
            }
            if (sceneData.collisionGrid.map) {
              collisionMap = sceneData.collisionGrid.map;
            }

            // Recreate collision grid visualization if it was shown
            if (collisionGridGroup) {
              scene.remove(collisionGridGroup);
              collisionGridGroup = createCollisionGrid();
              if (collisionGridGroup) {
                scene.add(collisionGridGroup);
                collisionGridGroup.visible = document.getElementById('show-collision')?.checked || false;
              }
            }
          }

          // Import meshes
          if (sceneData.meshes) {
            clearAllMeshes();

            sceneData.meshes.forEach(item => {
              let mesh = null;
              if (item.type === 'sphere') {
                mesh = createSphere(
                  new THREE.Vector3(item.position.x, item.position.y, item.position.z),
                  item.data.radius
                );
              } else if (item.type === 'box') {
                mesh = createBox(
                  new THREE.Vector3(item.position.x, item.position.y, item.position.z),
                  item.data.width,
                  item.data.height,
                  item.data.depth
                );
                mesh.rotation.set(item.rotation.x, item.rotation.y, item.rotation.z);
              } else if (item.type === 'brush') {
                const points = item.data.points.map(p => new THREE.Vector3(p.x, p.y, p.z));
                mesh = createBrushStroke(points, item.data.width);
              }

              if (mesh) {
                addMesh(mesh, item.type, item.data);
              }
            });
          }

          console.log('Scene import complete');
        } catch (err) {
          console.error('Failed to import scene:', err);
          alert('Failed to import scene: ' + err.message);
        }
      };
      reader.readAsText(file);
    });

    // ===== COMPLETE PLY EXPORT =====

    async function exportSplatToPLY(splatMesh) {
      if (!splatMesh) return null;

      console.log('Generating Splat PLY...');

      // Count splats
      let splatCount = 0;
      splatMesh.forEachSplat(() => { splatCount++; });

      console.log(`Found ${splatCount} splats`);

      // Create header
      const header =
        `ply
format binary_little_endian 1.0
element vertex ${splatCount}
property float x
property float y
property float z
property float nx
property float ny
property float nz
property float f_dc_0
property float f_dc_1
property float f_dc_2
property float opacity
property float scale_0
property float scale_1
property float scale_2
property float rot_0
property float rot_1
property float rot_2
property float rot_3
end_header
`;

      const headerEncoder = new TextEncoder();
      const headerBytes = headerEncoder.encode(header);

      // Calculate buffer size
      // 3 pos + 3 norm + 3 color + 1 opacity + 3 scale + 4 rot = 17 floats * 4 bytes = 68 bytes per splat
      const rowSize = 68;
      const bufferSize = headerBytes.length + splatCount * rowSize;
      const buffer = new ArrayBuffer(bufferSize);
      const view = new DataView(buffer);

      // Write header
      const uint8View = new Uint8Array(buffer);
      uint8View.set(headerBytes, 0);

      let offset = headerBytes.length;

      // Get current world transform of the splat (offsets)
      const positionOffset = splatMesh.position;
      const rotationOffset = splatMesh.quaternion;
      const scaleOffset = splatMesh.scale;

      // Iterate and write data
      splatMesh.forEachSplat((index, center, scales, quaternion, opacity, color) => {
        // Apply world transform to position
        // Note: We are only applying translation (offsets) as per user request "with its offsets value"
        // If the user rotated/scaled the splat object, we should apply that too.
        // The splatMesh.matrixWorld contains the full transform.

        const worldPos = center.clone().applyMatrix4(splatMesh.matrixWorld);

        // Write Position (x, y, z)
        // Converting Three.js (Y-up) to standard 3DGS (often Y-down).
        // Flipping Y and Z is a common conversion.
        view.setFloat32(offset + 0, worldPos.x, true);
        view.setFloat32(offset + 4, -worldPos.y, true);
        view.setFloat32(offset + 8, -worldPos.z, true);

        // Write Normals (0, 0, 0) - placeholders
        view.setFloat32(offset + 12, 0, true);
        view.setFloat32(offset + 16, 0, true);
        view.setFloat32(offset + 20, 0, true);

        // Write Color (f_dc_0, 1, 2)
        // SH DC component is related to RGB. 
        // Standard formula: RGB = 0.5 + C0 * SH
        // So SH = (RGB - 0.5) / C0
        // C0 = 0.28209479177387814
        const C0 = 0.28209479177387814;
        view.setFloat32(offset + 24, (color.r - 0.5) / C0, true);
        view.setFloat32(offset + 28, (color.g - 0.5) / C0, true);
        view.setFloat32(offset + 32, (color.b - 0.5) / C0, true);

        // Write Opacity (logit? or raw?)
        // Standard PLY usually stores opacity as logit (inverse sigmoid) or raw depending on loader.
        // 3DGS usually stores opacity passed through sigmoid in renderer, but in PLY it's raw.
        // However, `opacity` passed here is likely already 0-1.
        // If we write 0-1, loaders might expect logit.
        // Let's assume standard 3DGS loaders expect raw values that they pass through sigmoid.
        // Inverse sigmoid: log(p / (1 - p))
        // But wait, `SplatMesh` might give us the raw value or the sigmoid value.
        // Usually `opacity` in callback is 0-1.
        // If I write it as is, standard loaders might apply sigmoid again and it will be wrong?
        // Actually, standard 3DGS PLY stores opacity as a float.
        // Let's try writing the inverse sigmoid.
        const op = Math.max(0.0001, Math.min(0.9999, opacity));
        const logitOpacity = Math.log(op / (1 - op));
        view.setFloat32(offset + 36, logitOpacity, true);

        // Write Scale (log scale)
        // `scales` is likely linear. PLY expects log scale.
        // Apply global scale offset
        view.setFloat32(offset + 40, Math.log(scales.x * scaleOffset.x), true);
        view.setFloat32(offset + 44, Math.log(scales.y * scaleOffset.y), true);
        view.setFloat32(offset + 48, Math.log(scales.z * scaleOffset.z), true);

        // Write Rotation (quaternion)
        // Apply object rotation to splat rotation
        const worldRot = quaternion.clone().premultiply(rotationOffset);

        // Flip Y and Z to match position flip (if coordinate system change is X, -Y, -Z)
        // Quaternion (x, y, z, w) -> (x, -y, -z, w)
        view.setFloat32(offset + 52, worldRot.w, true);
        view.setFloat32(offset + 56, worldRot.x, true);
        view.setFloat32(offset + 60, -worldRot.y, true);
        view.setFloat32(offset + 64, -worldRot.z, true);

        offset += rowSize;
      });

      return buffer;
    }

    function exportCollisionMeshesToPLY() {
      if (createdMeshes.length === 0) return null;

      console.log('Generating Collision Mesh PLY...');

      try {
        const exporter = new PLYExporter();
        const group = new THREE.Group();

        createdMeshes.forEach(m => {
          if (m.mesh) {
            const clone = m.mesh.clone();
            // Ensure world transform is baked or preserved
            group.add(clone);
          }
        });

        return new Promise((resolve, reject) => {
          try {
            exporter.parse(group, (result) => {
              resolve(result);
            }, { binary: true });
          } catch (err) {
            reject(err);
          }
        });
      } catch (err) {
        console.error("Error preparing collision meshes for export:", err);
        return null;
      }
    }

    async function exportSinglePLY(splatMesh, meshes) {
      console.log('Generating Single PLY...');

      // 1. Count Splats
      let splatCount = 0;
      if (splatMesh) {
        splatMesh.forEachSplat(() => { splatCount++; });
      }

      // 2. Count Mesh Vertices and Faces
      let meshVertexCount = 0;
      let meshFaceCount = 0;
      const meshData = []; // Store processed mesh data to avoid re-processing

      meshes.forEach((m, index) => {
        console.log(`Processing mesh ${index}: type=${m.type}, id=${m.id}`);
        if (m.mesh && m.mesh.geometry) {
          const geo = m.mesh.geometry;
          const posAttr = geo.getAttribute('position');
          if (posAttr) {
            const vCount = posAttr.count;
            let fCount = 0;
            if (geo.index) {
              fCount = geo.index.count / 3;
              console.log(`  Indexed geometry: vCount=${vCount}, fCount=${fCount}`);
            } else {
              fCount = vCount / 3;
              console.log(`  Non-indexed geometry: vCount=${vCount}, fCount=${fCount}`);
            }

            meshVertexCount += vCount;
            meshFaceCount += fCount;

            meshData.push({
              mesh: m.mesh,
              vCount,
              fCount,
              indexed: !!geo.index
            });
          } else {
            console.warn(`  Mesh ${index} has no position attribute!`);
          }
        } else {
          console.warn(`  Mesh ${index} has no mesh or geometry!`);
        }
      });

      const totalVertexCount = splatCount + meshVertexCount;
      console.log(`Splats: ${splatCount}, Mesh Vertices: ${meshVertexCount}, Mesh Faces: ${meshFaceCount}`);

      // 3. Create Header
      const header =
        `ply
format binary_little_endian 1.0
element vertex ${totalVertexCount}
property float x
property float y
property float z
property float nx
property float ny
property float nz
property float f_dc_0
property float f_dc_1
property float f_dc_2
property float opacity
property float scale_0
property float scale_1
property float scale_2
property float rot_0
property float rot_1
property float rot_2
property float rot_3
element face ${meshFaceCount}
property list uchar int vertex_indices
end_header
`;

      const headerEncoder = new TextEncoder();
      const headerBytes = headerEncoder.encode(header);

      // 4. Calculate Buffer Size
      const vertexRowSize = 68;
      const faceRowSize = 13;

      const bufferSize = headerBytes.length + (totalVertexCount * vertexRowSize) + (meshFaceCount * faceRowSize);
      const buffer = new ArrayBuffer(bufferSize);
      const view = new DataView(buffer);

      // 5. Write Header
      const uint8View = new Uint8Array(buffer);
      uint8View.set(headerBytes, 0);

      let offset = headerBytes.length;

      // 6. Write Splats
      if (splatMesh) {
        const positionOffset = splatMesh.position;
        const rotationOffset = splatMesh.quaternion;
        const scaleOffset = splatMesh.scale;

        splatMesh.forEachSplat((index, center, scales, quaternion, opacity, color) => {
          const worldPos = center.clone().applyMatrix4(splatMesh.matrixWorld);

          // Position (Flip Y/Z)
          view.setFloat32(offset + 0, worldPos.x, true);
          view.setFloat32(offset + 4, -worldPos.y, true);
          view.setFloat32(offset + 8, -worldPos.z, true);

          // Normals (0)
          view.setFloat32(offset + 12, 0, true);
          view.setFloat32(offset + 16, 0, true);
          view.setFloat32(offset + 20, 0, true);

          // Color (SH DC)
          const C0 = 0.28209479177387814;
          view.setFloat32(offset + 24, (color.r - 0.5) / C0, true);
          view.setFloat32(offset + 28, (color.g - 0.5) / C0, true);
          view.setFloat32(offset + 32, (color.b - 0.5) / C0, true);

          // Opacity (logit)
          const op = Math.max(0.0001, Math.min(0.9999, opacity));
          const logitOpacity = Math.log(op / (1 - op));
          view.setFloat32(offset + 36, logitOpacity, true);

          // Scale (log, with global scale)
          view.setFloat32(offset + 40, Math.log(scales.x * scaleOffset.x), true);
          view.setFloat32(offset + 44, Math.log(scales.y * scaleOffset.y), true);
          view.setFloat32(offset + 48, Math.log(scales.z * scaleOffset.z), true);

          // Rotation (Flip Y/Z components)
          const worldRot = quaternion.clone().premultiply(rotationOffset);
          view.setFloat32(offset + 52, worldRot.w, true);
          view.setFloat32(offset + 56, worldRot.x, true);
          view.setFloat32(offset + 60, -worldRot.y, true);
          view.setFloat32(offset + 64, -worldRot.z, true);

          offset += vertexRowSize;
        });
      }

      // 7. Write Mesh Vertices
      let currentVertexOffset = splatCount;

      meshData.forEach(md => {
        const mesh = md.mesh;
        const posAttr = mesh.geometry.getAttribute('position');
        const normalAttr = mesh.geometry.getAttribute('normal');

        mesh.updateMatrixWorld();
        const matrixWorld = mesh.matrixWorld;
        const normalMatrix = new THREE.Matrix3().getNormalMatrix(matrixWorld);

        for (let i = 0; i < md.vCount; i++) {
          const localPos = new THREE.Vector3().fromBufferAttribute(posAttr, i);
          const worldPos = localPos.applyMatrix4(matrixWorld);

          // Position (Flip Y/Z)
          view.setFloat32(offset + 0, worldPos.x, true);
          view.setFloat32(offset + 4, -worldPos.y, true);
          view.setFloat32(offset + 8, -worldPos.z, true);

          // Normals
          let nx = 0, ny = 0, nz = 0;
          if (normalAttr) {
            const localNorm = new THREE.Vector3().fromBufferAttribute(normalAttr, i);
            localNorm.applyMatrix3(normalMatrix).normalize();
            nx = localNorm.x;
            ny = localNorm.y;
            nz = localNorm.z;
          }
          view.setFloat32(offset + 12, nx, true);
          view.setFloat32(offset + 16, -ny, true);
          view.setFloat32(offset + 20, -nz, true);

          // Color (Dummy)
          view.setFloat32(offset + 24, 0, true);
          view.setFloat32(offset + 28, 0, true);
          view.setFloat32(offset + 32, 0, true);

          // Opacity (Hidden)
          // logit(0.0001) ~ -9.2
          view.setFloat32(offset + 36, -9.2, true);

          // Scale (Hidden)
          // log(0.000001) ~ -13.8
          view.setFloat32(offset + 40, -13.8, true);
          view.setFloat32(offset + 44, -13.8, true);
          view.setFloat32(offset + 48, -13.8, true);

          // Rotation (Identity)
          view.setFloat32(offset + 52, 1, true);
          view.setFloat32(offset + 56, 0, true);
          view.setFloat32(offset + 60, 0, true);
          view.setFloat32(offset + 64, 0, true);

          offset += vertexRowSize;
        }

        md.startIndex = currentVertexOffset;
        currentVertexOffset += md.vCount;
      });

      // 8. Write Faces
      meshData.forEach(md => {
        const mesh = md.mesh;
        const geo = mesh.geometry;
        const startIndex = md.startIndex;

        if (md.indexed) {
          const indexAttr = geo.index;
          for (let i = 0; i < indexAttr.count; i += 3) {
            const a = indexAttr.getX(i) + startIndex;
            const b = indexAttr.getX(i + 1) + startIndex;
            const c = indexAttr.getX(i + 2) + startIndex;

            uint8View[offset] = 3;
            offset += 1;
            view.setInt32(offset, a, true);
            view.setInt32(offset + 4, b, true);
            view.setInt32(offset + 8, c, true);
            offset += 12;
          }
        } else {
          for (let i = 0; i < md.vCount; i += 3) {
            const a = i + startIndex;
            const b = i + 1 + startIndex;
            const c = i + 2 + startIndex;

            uint8View[offset] = 3;
            offset += 1;
            view.setInt32(offset, a, true);
            view.setInt32(offset + 4, b, true);
            view.setInt32(offset + 8, c, true);
            offset += 12;
          }
        }
      });

      return buffer;
    }

    document.getElementById('export-ply-package')?.addEventListener('click', async () => {
      const btn = document.getElementById('export-ply-package');
      const originalText = btn.textContent;
      btn.textContent = 'üì¶ Generating...';
      btn.disabled = true;

      try {
        const buffer = await exportSinglePLY(currentSplat, createdMeshes);

        if (buffer) {
          const blob = new Blob([buffer], { type: 'application/octet-stream' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = 'scene_merged.ply';
          a.click();
          URL.revokeObjectURL(url);
          console.log('Exported Single PLY');
        } else {
          alert('Nothing to export!');
        }
      } catch (err) {
        console.error('Failed to export PLY:', err);
        alert('Failed to export: ' + err.message);
      } finally {
        btn.textContent = originalText;
        btn.disabled = false;
      }
    });

    // Mouse interaction for tool usage
    let isToolMouseDown = false;

    renderer.domElement.addEventListener('mousedown', (event) => {

      // Don't interfere with camera rotation
      if (event.button !== 0) return;

      isToolMouseDown = true;
      isCreating = true;

      const pos = getWorldPosition(event);
      if (!pos) return;

      creationStart = pos.clone();

      if (activeTool === 'sphere') {
        // Create preview sphere
        previewMesh = createSphere(creationStart, 0.5);
        previewMesh.material = previewMaterial.clone();
        scene.add(previewMesh);
      } else if (activeTool === 'box') {
        // Create preview box
        previewMesh = createBox(creationStart, 0.5, boxHeight, 0.5);
        previewMesh.material = previewMaterial.clone();
        scene.add(previewMesh);
      } else if (activeTool === 'brush') {
        brushPoints.push(pos.clone());
      }
    });

    renderer.domElement.addEventListener('mousemove', (event) => {
      if (!isToolMouseDown || !isCreating || activeTool === 'none') return;

      const pos = getWorldPosition(event);
      if (!pos) return;

      if (activeTool === 'sphere' && previewMesh) {
        const radius = Math.max(0.5, creationStart.distanceTo(pos));
        scene.remove(previewMesh);
        previewMesh = createSphere(creationStart, radius);
        previewMesh.material = previewMaterial.clone();
        scene.add(previewMesh);

        updatePreviewSplatEdit('sphere', creationStart, new THREE.Euler(), new THREE.Vector3(1, 1, 1), radius);

      } else if (activeTool === 'box' && previewMesh) {
        const dx = Math.abs(pos.x - creationStart.x);
        const dz = Math.abs(pos.z - creationStart.z);
        const width = Math.max(0.5, dx * 2);
        const depth = Math.max(0.5, dz * 2);

        scene.remove(previewMesh);
        const center = new THREE.Vector3(
          (creationStart.x + pos.x) / 2,
          creationStart.y,
          (creationStart.z + pos.z) / 2
        );
        previewMesh = createBox(center, width, boxHeight, depth);
        previewMesh.material = previewMaterial.clone();
        scene.add(previewMesh);

        updatePreviewSplatEdit('box', center, new THREE.Euler(), new THREE.Vector3(width / 2, boxHeight / 2, depth / 2), 0);

      } else if (activeTool === 'brush') {
        // Add point if far enough from last point
        const lastPoint = brushPoints[brushPoints.length - 1];
        // Smoother sampling: 0.05m instead of 0.1m
        if (!lastPoint || pos.distanceTo(lastPoint) > 0.05) {
          brushPoints.push(pos.clone());

          // Update preview
          if (previewMesh) scene.remove(previewMesh);
          if (brushPoints.length >= 2) {
            // Use CatmullRomCurve3 for smooth path
            const curve = new THREE.CatmullRomCurve3(brushPoints);
            // Higher tubular segments for smoothness
            const geometry = new THREE.TubeGeometry(curve, brushPoints.length * 4, brushWidth / 2, 8, false);
            previewMesh = new THREE.Mesh(geometry, previewMaterial.clone());
            scene.add(previewMesh);

            // Add capsule SDF for the new segment
            if (lastPoint) {
              addBrushCapsule(lastPoint, pos, brushWidth / 2);
            }
          }
        }
      }
    });

    window.addEventListener('mouseup', (event) => {
      if (!isToolMouseDown || !isCreating || activeTool === 'none') {
        isToolMouseDown = false;
        return;
      }

      isToolMouseDown = false;
      isCreating = false;

      const pos = getWorldPosition(event);
      if (!pos || !creationStart) {
        clearPreview();
        return;
      }

      // Finalize creation
      if (activeTool === 'sphere') {
        const radius = Math.max(0.5, creationStart.distanceTo(pos));

        // Extract splat points within the sphere
        console.log('=== Creating Collision from Sphere Selection ===');
        console.log('Center:', creationStart, 'Radius:', radius);

        const selectedPoints = getPointsInSphere(currentSplat, creationStart, radius);

        let mesh = null;
        if (selectedPoints.length > 0) {
          // Create convex hull from selected points
          mesh = createConvexHullFromPoints(selectedPoints);
          console.log('‚úì Created convex hull mesh from', selectedPoints.length, 'points');
        } else {
          // Fallback to simple sphere geometry if no points found
          console.warn('No splat points found in sphere, using simple geometry');
          mesh = createSphere(creationStart, radius);
        }

        if (mesh) {
          mesh.visible = false; // Invisible but exists for raycasting
          mesh.name = 'Sphere Selection';
          collisionObjects.push(mesh);

          // Persist SplatEdit
          const savedSplatEdit = previewSplatEdit;
          previewSplatEdit = null;

          addMesh(mesh, 'sphere', {
            radius,
            center: creationStart.clone(),
            splatEdit: savedSplatEdit,
            pointCount: selectedPoints.length
          });
        }
      } else if (activeTool === 'box') {
        const dx = Math.abs(pos.x - creationStart.x);
        const dz = Math.abs(pos.z - creationStart.z);
        const width = Math.max(0.5, dx * 2);
        const depth = Math.max(0.5, dz * 2);
        const center = new THREE.Vector3(
          (creationStart.x + pos.x) / 2,
          creationStart.y,
          (creationStart.z + pos.z) / 2
        );

        // Extract splat points within the box
        console.log('=== Creating Collision from Box Selection ===');
        console.log('Center:', center, 'Size:', width, 'x', boxHeight, 'x', depth);

        const selectedPoints = getPointsInBox(currentSplat, center, width, boxHeight, depth);

        let mesh = null;
        if (selectedPoints.length > 0) {
          // Create convex hull from selected points
          mesh = createConvexHullFromPoints(selectedPoints);
          console.log('‚úì Created convex hull mesh from', selectedPoints.length, 'points');
        } else {
          // Fallback to simple box geometry if no points found
          console.warn('No splat points found in box, using simple geometry');
          mesh = createBox(center, width, boxHeight, depth);
        }

        if (mesh) {
          mesh.visible = false; // Invisible
          mesh.name = 'Box Selection';
          collisionObjects.push(mesh);

          // Persist SplatEdit
          const savedSplatEdit = previewSplatEdit;
          previewSplatEdit = null;

          addMesh(mesh, 'box', {
            width,
            height: boxHeight,
            depth,
            center: center.clone(),
            splatEdit: savedSplatEdit,
            pointCount: selectedPoints.length
          });
        }
      } else if (activeTool === 'brush' && brushPoints.length >= 2) {
        // NEW APPROACH: Create collision directly from brush points using tube geometry
        console.log('=== Creating Collision from Brush Points ===');
        console.log('Brush points:', brushPoints.length, 'Brush width:', brushWidth);

        // Create collision mesh directly from brush points (no SDF sampling)
        const mesh = createCollisionMeshFromBrushPoints(brushPoints, brushWidth);

        if (mesh) {
          mesh.visible = false;
          mesh.name = 'Brush Selection';
          collisionObjects.push(mesh);

          const savedSplatEdit = previewSplatEdit;
          previewSplatEdit = null;

          addMesh(mesh, 'brush', {
            points: brushPoints.map(p => p.clone()),
            width: brushWidth,
            splatEdit: savedSplatEdit
          });

          console.log('‚úì Created collision mesh from brush points (tube geometry)');
        } else {
          console.error('Failed to create mesh from brush points');
        }
      }

      clearPreview();
    });

    // Escape key to cancel
    window.addEventListener('keydown', (event) => {
      if (event.key === 'Escape') {
        clearPreview();
        isCreating = false;
        isToolMouseDown = false;
      }
    });

    // ===== COLLISION DETECTION WITH MESHES =====
    const collisionObjects = []; // Array to hold invisible meshes for raycasting

    function getGroundHeight(x, z) {
      // 1. Check grid height first
      let groundY = floorY;
      const cell = getGridCell(x, z);
      if (cell) {
        groundY = cell.y;
      }

      // 2. Raycast against collision meshes
      if (collisionObjects.length > 0) {
        const rayOrigin = new THREE.Vector3(x, 100, z);
        const rayDir = new THREE.Vector3(0, -1, 0);
        raycaster.set(rayOrigin, rayDir);

        const intersects = raycaster.intersectObjects(collisionObjects, false);
        if (intersects.length > 0) {
          // Find the highest intersection point
          // intersects are sorted by distance, so the first one is the highest (closest to 100)
          const meshY = intersects[0].point.y;
          if (meshY > groundY) {
            groundY = meshY;
          }
        }
      }

      return groundY;
    }

    function checkMeshCollision(x, y, z) {
      // This function is now less critical for movement blocking if we use slope check
      // But we can still use it for "ceiling" checks or explicit walls if needed.
      // For now, let's rely on getGroundHeight for floor/stairs.
      // We might still want to block if we hit the SIDE of a mesh?
      // Raycast down handles "on top". 
      // To handle "hitting a wall", we need to check if the step up is too high.
      return false;
    }

    renderer.setAnimationLoop(function animate(time) {
      try {
        const dt = (time - lastTime) / 1000;
        lastTime = time;

        updatePlayer(dt);
        updateDrone(dt);
        updateCamera();
        // updateCoordInfo(); // Removed

        renderer.render(scene, camera);
      } catch (err) {
        const debugDiv = document.getElementById('movement-debug');
        if (debugDiv) {
          debugDiv.innerHTML = `<span style="color:red">ERROR: ${err.message}</span>`;
          debugDiv.style.backgroundColor = "rgba(0,0,0,0.8)";
        }
        console.error(err);
        renderer.setAnimationLoop(null); // Stop loop
      }
    });
    // Global Error Handler for Init
    window.onerror = function (message, source, lineno, colno, error) {
      const debugDiv = document.getElementById('movement-debug');
      if (debugDiv) {
        debugDiv.innerHTML = `<span style="color:red; font-weight:bold;">CRITICAL ERROR: ${message} at line ${lineno}</span>`;
        debugDiv.style.display = 'block';
      } else {
        console.error(`CRITICAL ERROR: ${message} at line ${lineno}`);
      }
    };
  </script>
  </body>

  </html>